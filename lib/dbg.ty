import os
import chalk (chalk)
import readln (readln)
import tdb
import term
import time (utime)
import math (log10)
import ty
import log (..)

pub macro Source   = 1
pub macro Bytecode = 2

DEFAULT_LOG_PATH = './tdb.log'

logging({
    level: INFO,
    path: './tdb.log'
})

class TDBError < RuntimeError {
    init(msg: String) {
        super(msg)
    }
}

chalk.fg0    = '#e1c78f'
chalk.fg1    = '#ddc7a1'
chalk.red    = '#ea6962'
chalk.aqua   = '#89b482'
chalk.orange = '#e78a4e'
chalk.yellow = '#d8a657'
chalk.green  = '#a9b665'
chalk.green2 = '#9dbd60'
chalk.blue   = '#7daea3'
chalk.blue2  = '#3193ce'
chalk.purple = '#d3869b'
chalk.aqua   = '#89b482'
chalk.grey   = '#847a6d'
chalk.pink   = '#d677be'

let groups = %{
    'fg0': 'id',
    'fg1': '[ ] { } ( ) . .? , ] ->',
    'orange': '
        =   ==  ++  --  +   -  *    /   %   ^    |    &    <=   >=
        +=  -=  *=  /=  %=  @  #    &&  ||  <=>  !    ~
        ~>  =>  $~> >   <  !=  ??   >>  <<  <<=  >>=  |>
        *** &&& <$> <%> ?> <?  <*>  *>  <*  ..%. .%.. .%
        ::  ?=  |=  &=  ^=  ?  $    ..  ... ?:
    ',
    'purple': 'true false nil int float use import',
    'red': '
        for        while    if     let       and    fn     const
        do         try      catch  operator  or     in     yield
        match      else     with   break     pub    as     static
        continue   return   macro  where     not    throw  defer

        id_keyword
    ',
    'b yellow': 'type type_member',
    'yellow': 'class tag trait id_module',
    'green': 'string " f-string',
    ' green2': 'fun fun_member',
    'blue': 'id_member id_field',
    'blue2': 'typeof',
    'aqua': 'regex',
    'grey': 'comment ; :',
    'pink': 'pp id_macro fun_macro $$[ $$] $$'
}

let colors = [ %{ t: c for t in g.words() } for c, g in groups ].sum()

@memoized
fn color-and-break(module: String) -> Array[(Int, String)] {
    if not let ($source, $tokens) = (ty.text(module), ty.tokens(module)) {
        throw TDBError("failed to fetch source information for {module}")
    }

    let tokens = tokens.remove!(nil).map!(t -> match t {
        {id: /^[A-Z]\w*[a-z]\w*$/, *}            => do { let x: _ = t; ({*x, type: 'type'}) },
        {id, end, *} and source[end.byte] == '(' => do { let x: _ = t; ({*x, type: 'fun'}) },
        _ => t
    })

    let parts = [(it, '') for source]

    fn idx-of(off: Int, start: (Int, Int) = (0, 0)) -> (Int, Int) {
        let (n0, i0) = start
        let n = n0

        for i0..#parts {
            if n == off {
                return (n, it)
            }

            n += parts[it][0].size()

            if (n > off) && (n0 == 0) {
                return (n, it)
            }
        }

        (n0 == 0) ? (n, #parts) : idx-of(off)
    }

    let st = (0, 0)
    for {start, end, type, ?kind, *} in tokens {
        continue if not let $color = colors[[type, ?kind].join('_')]

        let st0 = idx-of(start.byte, st)
        let st1 = idx-of(end.byte, st0)

        let (_, i) = st0
        let (_, j) = st1

        for i..j {
            parts[it] = (parts[it][0], color)
        }

        st = st1
    }

    parts.group-by!(&1).map!(group -> (group.map(&0).str(), group[0][1]))

    let out = Blob()

    for (text, fg) in parts {
        out.push(fg ? "[{fg}]{chalk::escape(text)}[/]" : chalk::escape(text))
    }

    out.str!().lines().enumerate!()
}

fn next-line(line: Int) -> (Token -> Bool) do (
    match ({start, *}) => start.line != line
)

fn next-call(start-func, start-fp) do (
    match ({fp, *}) => (fp != start-fp)
)

fn end-of-expr() (
    match tdb.span() {
        (lo, hi) => match ({ip, *}) => (ip < lo) || (ip >= hi),
        _        => nil
    }
)

let stop-cond = nil
let step = nil
let current-line = -1
let current-mode = Source
let current-range = 0..1
let expr-span = nil
let depth = 0
let state: _ = nil

let keybinds = %{
    '<C-u>': fn (h, w) {
        if state {
            current-range -= (h / 4)
            print-source(state.mod, current-range, state)
        }
    },
    '<C-d>': fn (h, w) {
        if state {
            current-range += (h / 4)
            print-source(state.mod, current-range, state)
        }
    },
}

let readln = readln@(_, keybinds=keybinds, erase=false, **)

tdb.hook = fn hook() {
    state = tdb.state()

    let { mod, file, expr, prog
        , insn, ip, fp, sp, func } = state

    if not let ty.src $~> {start, end, *} = expr {
        step()
        return
    }

    if stop-cond != nil && !stop-cond({*state, start, end}) {
        step()
        return
    }

    expr-span    = (start.line == end.line) ? (start.col, end.col) : nil
    current-line = start.line
    stop-cond    = nil

    let (H, W) = term::size(1)

    depth += 1
    defer depth -= 1

    match current-mode {
        Source => {
            if current-line not in current-range {
                current-range = current-line.range(-(H/3), H/2)
            }
            print-source(mod, current-range, state)
        },

        Bytecode => {
            tdb.list()
        }
    }

    while match readln("(tdb)[{depth}] ") {
        /^p (.*)$/ => match tdb.eval($1) {
            Err(msg) => print(msg),
            Ok(val)  => pp(val)
        },

        /^b (.*)$/ => match tdb.eval($1) {
            Err(msg) => print(msg),
            Ok(fun)  => tdb.breakpoint(fun)
        },

        /^x(?:\/(\d+))?/ => {
            let max = int($1) ?? 32
            let n = 0

            while let Some(x) = tdb.stack(n++) {
                print("  {n:3}   {pretty(x, width=W - 8, oneline=true)}")
            }

            if n == 0 {
                print(chalk"[blue](empty stack)[/]")
                continue
            }
        },

        'l' => {
            if prog != nil {
                print-source(mod, current-range, state)
                current-mode = Source
            }
        },

        /l (\d+)(?:\s*-\s*(\d+))?/ => {
            if prog != nil {
                let lo = int($1) - 1
                let hi = int($2 || (lo + 20)) - 1
                print-source(mod, lo...hi, state)
                current-mode = Source
            }
        }

        'd' => {
            tdb.list()
            current-mode = Bytecode
        },

        'bt' => {
            tdb.backtrace()
        },

        'st' => {
            pp(state)
        },

        'lo' => {
            if let $locals = tdb.locals() {
                pp(tuple(**tdb.locals()))
            } else {
                print(chalk"[bright red]No locals![/]")
            }
        },

        'n' or '' => match current-mode {
            Source => {
                stop-cond = next-line(current-line)
                step = tdb.over
                break
            },

            Bytecode => {
                stop-cond = (-> true)
                step = tdb.over
                break
            }
        },

        's' => {
            stop-cond = next-call(func, fp)
            step = () -> tdb.into() || tdb.over()
            break
        },

        '1' => {
            stop-cond = (-> true)
            step = tdb.over
            break
        },

        'fe' => {
            stop-cond = end-of-expr()
            step = tdb.over
            break
        },

        'c' => {
            stop-cond = nil
            return
        },

        'q' => {
            os::exit(0)
        },

        c => {
            print("bro? {c}")
        }
    }

    step()

    return nil
}

fn print-source(module: String, range: Range, state: _) {
    warn!(range)
    let lines = color-and-break(module)
    error!(range)
    error!("#lines = {#lines}")
    let range = range.clamp(0, #lines)
    critical!(range)

    let buf = Blob()
    let put = fn (x) {
        buf.push(str(x))
        buf.push('\n')
    }

    print("\x1b[2J\x1b[H", :flush)
    put(chalk"[yellow]File:[/] [blue]{state.file}[/]")

    let ndigit = int(log10(range.high())) + 1

    try {
        for (i, chalk::Text@(_, chalk) ~> source-line) in lines[range] {
            let highlight = text -> chalk"[bright yellow bold]{text}[/]"
            let margin = (i == current-line)
                       ? "     --> {i + 1:{ndigit}} |" >> highlight
                       : "         {i + 1:{ndigit}} |"
            if i == current-line {
                if expr-span != nil {
                    source-line = source-line.style-span(expr-span, 'b u.-#7ead85')
                }
                source-line = chalk"[bg-#3c3836]{source-line:-100}[/]"
            }
            put(chalk"{margin} {source-line}")
        }
        put(chalk"[yellow]Current instruction:[/] [blue]{state.insn}[/]")
        print(buf.str!(), end='')
    } catch chalk::ChalkError(e) {
        print(chalk"[bright red b]chalk error[/]: {pretty(e)}")
    }
}

