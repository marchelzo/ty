import ty

tag Code, Text, Expr, Embed, IfDef;

use TemplateToken =
    Code[String]
  | Text[String]
  | Expr[String]
  | Embed[String]
  | IfDef[(String, String)]

fn parse(s: String) -> Array[TemplateToken] {
    let ts = []

    function go(i, j) {
        if j == #s {
            ts.push(Text(s.splice(i, j)))
        } else if let [_, code] = s.slice(j).match(/^<%=((?:(?!%>).)+)%>/) {
            ts.push(Text(s.splice(i, j)))
            ts.push(Expr(code))
            go(j + #code + 5, j + #code + 5)
        } else if let [_, code] = s.slice(j).match(/^<%@((?:(?!%>).)+)%>/) {
            ts.push(Text(s.splice(i, j)))
            ts.push(Embed(code))
            go(j + #code + 5, j + #code + 5)
        } else if let [_, var, code] = s.slice(j).match(/^<%\?(\w+)((?:(?!%>).)+)%>/) {
            ts.push(Text(s.splice(i, j)))
            ts.push(IfDef(var, code))
            go(j + #code + #var + 5, j + #code + #var + 5)
        } else if let [_, code] = s.slice(j).match(/^<%((?:(?!%>).)+)%>/) {
            ts.push(Text(s.splice(i, j)))
            ts.push(Code(code))
            go(j + #code + 4, j + #code + 4)
        } else {
            go(i, j + 1)
        }
    }

    go(0, 0)

    ts
}

fn generate-code(tokens: Array[TemplateToken]) -> String {
    let chunks = []
    let string = []
    
    fn flush-string() {
        if #string > 0 {
            chunks.push("_ety_push(\"{string.str()}\");\n")
            string = []
        }
    }

    for match tokens {
       Text(s) => do {
            string.push(
                s.comb(/\n[ \t]*\z/)
                 .sub(/\\/, '\\\\')
                 .sub('\n', '\\n')
                 .sub('\'', '\\\'')
            )
        },

        Code(src) => do {
            flush-string()
            chunks.push("{src}\n")
        },

        Expr(expr) =>
            string.push("\{{expr}\}"),

        Embed(path) => do {
            flush-string()
            let source = slurp(path.strip())
            let tokens = parse(source)
            chunks.push(generate-code(tokens))
        },

        IfDef(v, s) => do {
            flush-string()
            chunks.push("ifdef {v} {s}")
        }
    }
    
    flush-string()
    
    chunks.join()
}

pub fn compile(source, vars) -> _ {
    let body = generate-code(parse(source))
    let params = ["{v}: _" for v in vars].join(', ')
    let prog = (
        "(
       \>  fn ({params}) \{
       \>    let _ety_blob = ::blob();
       \>    let _ety_push = _ety_blob.push;
       \>    {body};
       \>    _ety_blob.str!()
       \>  \}
       \>)"
    )
    return __eval__(prog)
}
