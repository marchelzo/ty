import ty

tag Code, Text, Expr, Embed, IfDef;

use TemplateToken =
    Code[String]
  | Text[String]
  | Expr[String]
  | Embed[String]
  | IfDef[(String, String)]

fn parse(s: String) -> Array[TemplateToken] {
    let tokens = []
    let end = #s

    let i = 0
    let j = 0

    while j < end {
        if let [_, code] = s.slice(j).match(/^<%=((?:(?!%>).)+)%>/) {
            tokens.push(Text(s.splice(i, j)))
            tokens.push(Expr(code))
            j += #code + 5
            i = j
        } else if let [_, code] = s.slice(j).match(/^<%@((?:(?!%>).)+)%>/) {
            tokens.push(Text(s.splice(i, j)))
            tokens.push(Embed(code))
            j += #code + 5
            i = j
        } else if let [_, var, code] = s.slice(j).match(/^<%\?(\w+)((?:(?!%>).)+)%>/) {
            tokens.push(Text(s.splice(i, j)))
            tokens.push(IfDef(var, code))
            j += #code + #var + 5
            i = j
        } else if let [_, code] = s.slice(j).match(/^<%((?:(?!%>).)+)%>/) {
            tokens.push(Text(s.splice(i, j)))
            tokens.push(Code(code))
            j += #code + 4
            i = j
        } else {
            j += 1
        }
    }

    if i <= end {
        tokens.push(Text(s.splice(i, j)))
    }

    tokens
}

fn generate-code(tokens: Array[TemplateToken]) -> String {
    let chunks = []
    let string = []
    
    fn flush-string() {
        if #string > 0 {
            chunks.push("_ety_push(\"{string.join()}\");\n")
            string = []
        }
    }

    for match tokens {
       Text(s) => do {
            string.push(
                s.comb(/\n[ \t]*\z/)
                 .sub(/[\\"{}\n\t]/, match {
                    '\n' => '\\n',
                    '\t' => '\\t',
                    ch   => "\\{ch}",
                 })
            )
        },

        Code(src) => do {
            flush-string()
            chunks.push("{src}\n")
        },

        Expr(expr) =>
            string.push("\{{expr}\}"),

        Embed(path) => do {
            flush-string()
            let source = slurp(path.strip())
            let tokens = parse(source)
            chunks.push(generate-code(tokens))
        },

        IfDef(v, s) => do {
            flush-string()
            chunks.push("ifdef {v} {s}")
        }
    }
    
    flush-string()
    
    chunks.join()
}

pub fn compile(source, vars) -> _ {
    let body = generate-code(parse(source))
    let params = ["{v}: _" for v in vars].join(', ')
    let prog = (
        "(
       \>  fn ({params}) \{
       \>    let _ety_blob = ::blob();
       \>    let _ety_push = _ety_blob.push;
       \>    {body};
       \>    _ety_blob.str!()
       \>  \}
       \>)"
    )
    __eval__(prog)
}
