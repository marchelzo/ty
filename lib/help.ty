import ty
import ty.lex as lex
import ty.parse as parse
import ty.token as tok
import ty.types as types
import os
import chalk (chalk, Text)
import json
import readln (readln, ListCompletions, CycleCompletions)
import ffi as c (C!)

let table: Dict[_, (String, String, String)] = %{}

macro doc! {
    let (parse.show ~> name, func) = parse.stmt(0, :raw)
    let (parse.show ~> proto, _) = parse.stmt(99, :raw)

    if tok.peek().type == '->' {
        tok.next()
        let (parse.show ~> rt, _) = parse.stmt(0, :raw)
        proto = "{proto} -> {rt}"
    }

    let help = tok.next().str

    $$[
        table[$$(func)] = (
            $$(ty.String(name)),
            $$(ty.String(proto)),
            $$(ty.String(help))
        )
    $$]
}

doc! Array.sort
(by: ?Function, cmp: ?Function, desc: ?Bool)
'''
    Return a copy of the array with the elements sorted
    in ascending order.

    by:
        Sort by(xi) <=> by(xj) instead of xi <=> xj

    cmp:
        Sort by cmp(xi, xj) instead of xi <=> xj

    desc:
        When true, reverse the usual sorting order.
'''

doc! print
(*args, sep: String = ', ', end: String = '\n', flush: Bool = false)
'''
    Print each argument to stdout.
'''

doc! eprint
(*args, sep: String = ', ', end: String = '\n', flush: Bool = false)
'''
    Print each argument to stderr.
'''

doc! os::getaddrinfo
(
    hostname: String,
    service: String | Int,
    family: Int,
    socktype: Int,
    protocol: Int,
    flags: ?Int
) -> Ok([{family: Int, type: Int, protocol: Int, address: Blob, canonname: ?String}]) | Err(Int)
'''
    See getaddrinfo(3).

    Example
    -------

        let addr = match getaddrinfo('www.google.com', 80, AF_INET, SOCK_STREAM, 0) {
            Ok([a, *]) => a,
            Err(e) => {
                eprint("getaddrinfo(): {gai_strerror(e)}")
                exit(1)
            }
        }
'''

doc! os::sendto
(socket: Int, data: Blob | String, flags: Int, address: Blob) -> Int
'''
    See sendto(2).

    Example
    -------


        let sock = socket(AF_INET, SOCK_DGRAM, 0)

        let Ok([&.address ~> addr]) = getaddrinfo(...)

        if sendto(sock, "Hello!", 0, addr) < 0 {
            eprint(...)
            return -1
        }
'''

doc! os::recvfrom
[
    (socket: Int, buffer: Blob, n: Int, flags: Int) -> Int,
    (socket: Int, n: Int, flags: Int) -> Int
]
'''
    See recvfrom(2).

    Example
    -------

    let b = Blob()

    while recvfrom(sock, b, 4096, 0) > 0 {
        print("Got a message: {b.str()}")
        b.clear()
    }
'''

doc! os::exec
(argv: [String]) -> Int
'''
    See execvp(2).

    Example
    -------

    if os.exec(['nc', '-u', '-p3000']) != 0 {
        eprint("exec(): {errno.str()}")
        os.exit(1)
    }
'''

pub fn help(x) {
    let x = docRef(x)

    let doc = fn (x: Any) {
        return table[x] ?? doc(x)
    }

    let helpString = Blob()
    let p = fn (*args, sep=', ', end='\n') {
        helpString.push(args.join(sep) ?? '');
        helpString.push(end);
    }

    fn pdoc(s, indent) {
        let lines = s.lines().dropWhile!(/^\s*$/)

        // Remove trailing empty lines at the end.
        while #lines > 0 && lines[-1].match?(/^\s*$/) {
            lines.pop()
        }

        // Find the leading whitespace length common to all lines
        let leading = lines.map(&match!(/^\s*/) |> &len).min()

        for line in lines.map!(&slice(leading)) {
            p(''.lpad(indent), line, sep: '')
        }
    }

    match doc(x) {
        (name, doc, [*ms]) => {
            p("class {name}:")
            if doc != nil {
                p()
                pdoc(doc, 4)
            }
            for (name, proto, doc) in ms {
                p()
                if doc != nil {
                    p("    {name.comb(/^\w+\./)}{proto}:")
                    p()
                    pdoc(doc, 6)
                } else {
                    p("    {name.comb(/^\w+\./)}{proto}")
                }
            }
            p()
        },

        (name, proto, doc) => {
            if doc != nil {
                p("{name}{proto}:")
                p()
                pdoc(doc, 4)
                p()
            } else {
                p("{name}{proto}")
            }
        },

        nil => {
            p("No help for {x}.")
        }
    }

    let p = os.spawn(['less', '-FRX'], stdin=os.SPAWN_PIPE)
    os.write(p.stdin, helpString.str!())
    os.close(p.stdin)
    os.waitpid(p.pid)
}

chalk.fg0    = '#e1c78f'
chalk.fg1    = '#ddc7a1'
chalk.red    = '#ea6962'
chalk.aqua   = '#89b482'
chalk.orange = '#e78a4e'
chalk.yellow = '#d8a657'
chalk.green  = '#a9b665'
chalk.green2 = '#9dbd60'
chalk.blue   = '#7daea3'
chalk.blue2  = '#3193ce'
chalk.purple = '#d3869b'
chalk.aqua   = '#89b482'
chalk.grey   = '#847a6d'
chalk.pink   = '#d677be'

let groups = %{
    'fg0': 'id',
    'fg1': '[ ] { } ( ) . .? , ] ->',
    'orange': '
        =   ==  ++  --  +   -  *    /   %   ^    |    &    <=   >=
        +=  -=  *=  /=  %=  @  #    &&  ||  <=>  !    ~
        ~>  =>  $~> >   <  !=  ??   >>  <<  <<=  >>=  |>
        *** &&& <$> <%> ?> <?  <*>  *>  <*  ..%. .%.. .%
        ::  ?=  |=  &=  ^=  ?  $    ..  ... ?:
    ',
    'purple': 'true false nil int float use import',
    'red': '
        for        while    if     let       and    fn     const
        do         try      catch  operator  or     in     yield
        match      else     with   break     pub    as     static
        continue   return   macro  where     not    throw  defer

        id_keyword
    ',
    'b yellow': 'type type_member',
    'yellow': 'class tag trait id_module',
    'green': 'string " f-string',
    ' green2': 'fun fun_member',
    'blue': 'id_member id_field',
    'blue2': 'typeof',
    'aqua': 'regex',
    'grey': 'comment ; :',
    'pink': 'pp id_macro fun_macro $$[ $$] $$'
}

let colors = [ %{ t: c for t in g.words() } for c, g in groups ].sum()

fn color-and-break(source: String) -> Array[(Int, String)] {
    let tokens: Array[_] = match ty.parse(source, tokens=true) {
        (Ok((_, {tokens, *})) or Err({tokens, *}))
            => tokens,

        err => do { print(err); return [(0, chalk::escape(source))] }
    }

    let tokens = tokens.remove!(nil).map!(t -> match t {
        {id: /^[A-Z]\w*[a-z]\w*$/, *}            => do { let x: _ = t; ({*x, type: 'type'}) },
        {id, end, *} and source[end.byte] == '(' => do { let x: _ = t; ({*x, type: 'fun'}) },
        _ => t
    })

    let parts = [(it, '') for source]

    fn idx-of(off: Int, start: (Int, Int) = (0, 0)) -> (Int, Int) {
        let (n0, i0) = start
        let n = n0

        for i0..#parts {
            if n == off {
                return (n, it)
            }

            n += parts[it][0].size()

            if (n > off) && (n0 == 0) {
                return (n, it)
            }
        }

        (n0 == 0) ? (n, #parts) : idx-of(off)
    }

    let st = (0, 0)
    for {start, end, type, ?kind, *} in tokens {
        continue if not let $color = colors[[type, ?kind].join('_')]

        let st0 = idx-of(start.byte, st)
        let st1 = idx-of(end.byte, st0)

        let (_, i) = st0
        let (_, j) = st1

        for i..j {
            parts[it] = (parts[it][0], color)
        }

        st = st1
    }

    parts.group-by!(&1).map!(group -> (group.map(&0).str(), group[0][1]))

    let out = Blob()

    for (text, fg) in parts {
        out.push(fg ? "[{fg}]{chalk::escape(text)}[/]" : chalk::escape(text))
    }

    out.str!().lines().enumerate!()
}

pub fn pretty-code(prompt: String, line: [String], i: Int) -> String {
    let before = line[;i].str() ?? ''
    let all = line.str() ?? ''

    if let [(_, _before), *] = color-and-break(before) and
       let [(_, _all), *] = color-and-break(all) {
        before = Text(_before, chalk)
        all = Text(_all, chalk)
    }

    "{prompt}{all}\r{prompt}{before}"
}

fn type-completions(type: _, prefix: String) -> Array[_] {
    fn label(method) {
        [chalk"[bright blue]{method.name}[/][grey]:[/] ", types::show(method.type)]
    }

    match type {
        types::Object(_) => do {
            let info = types.info(type)

            let members = (
                info.methods
              + info.fields
              + info.getters
              + info.setters
            )

            let completions = members
                .filter(\_.name.starts?(prefix))
                .filter(\_.type !:: types::Intersect)
                .map(${(label(it), it.name[#prefix;])})
                .sort(by=\"{_.0}")

            for info.traits {
                completions += type-completions(it, prefix)
            }

            if info.`super` != nil {
                completions += type-completions(info.`super`, prefix)
            }

            completions.uniq()
        }

        types::Record(members ~> $fields)
            => fields.keys()
                .filter(\_.starts?(prefix))
                .map(\_[#prefix;])
                .sort(),

        _ => []
    }
}

fn mod-completions(mod: Dict[String, _], prefix: String) -> [(Text, String)] {
    let completions = []

    for name, item in mod if name.starts?(prefix) {
        let label = match item {
            _ns: Dict => [chalk"[bright blue]{name}[/][grey]:[/] ", chalk"[b yellow]namespace[/]"],
            {type, *} => [chalk"[bright blue]{name}[/][grey]:[/] ", types::show(type)],
            _         => nil
        }

        if label {
            completions.push((label, name[#prefix;]))
        }
    }

    completions
}

pub fn tab-complete(before: String, after: String) -> readln::CompletionAction {
    let expr = match ty.parse("{before} .? \{") {
        Err({last: $expr, *}) => expr,

        Ok((expr, _)) => expr,

        _ => do return ListCompletions([])
    }

    let expr = match expr {
        ty.Let(_, e) => e,
        _            => expr
    }

    if (before[-1] != '.') and let ty.Id({name, *}) = expr {
        return CycleCompletions(mod-completions(ty.module(), name))
    }


    let (subject, prefix) = match expr {
        ty.MemberAccess(o, m) and (before[-1] != '.')
            => (o, m),
        _
            => (expr, '')
    }

    if let ty.Id({name, *}) = subject and let $mod = ty.module(name) {
        return CycleCompletions(mod-completions(mod, prefix))
    }

    CycleCompletions(
        type-completions(
            types.infer(subject),
            prefix
        )
    )
}
