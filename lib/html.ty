import xml
import path (Path)

fn is-name-char(ch: String) -> Bool {
    ch.match?(/^[A-Za-z0-9_:-]$/)
}

fn is-space(ch: String) -> Bool {
    ch.match?(/^\s$/)
}

fn xpath-literal(s: String) -> String {
    if !s.match?(/'/) {
        return "'{s}'"
    }

    if !s.match?(/\"/) {
        return "\"{s}\""
    }

    let parts = s.split("'")
    let out = ""

    for i in ..#parts {
        if i > 0 {
            out = "{out},\"'\","
        }
        out = "{out}'{parts[i]}'"
    }

    "concat({out})"
}

fn parse-simple-selector(simple: String) -> String {
    let chars = simple.chars()
    let i = 0
    let n = #chars

    let tagname = '*'

    if i < n {
        if chars[i] == '*' {
            tagname = '*'
            i += 1
        } else if is-name-char(chars[i]) {
            tagname = ''
            while i < n && is-name-char(chars[i]) {
                tagname += chars[i]
                i += 1
            }
        }
    }

    let preds = []

    fn skip-ws() {
        while i < n && is-space(chars[i]) { i += 1 }
    }

    while i < n {
        let ch = chars[i]

        if ch == '#' {
            i += 1
            let id = ''
            while i < n && is-name-char(chars[i]) {
                id += chars[i]
                i += 1
            }
            preds.push("@id={xpath-literal(id)}")
            continue
        }

        if ch == '.' {
            i += 1
            let cls = ''
            while i < n && is-name-char(chars[i]) {
                cls += chars[i]
                i += 1
            }
            preds.push("contains(concat(' ', normalize-space(@class), ' '), ' {cls} ')")
            continue
        }

        if ch == '[' {
            i += 1
            skip-ws()
            let name = ''
            while i < n && is-name-char(chars[i]) {
                name += chars[i]
                i += 1
            }
            skip-ws()

            let val: ?String = nil

            if i < n && chars[i] == '=' {
                i += 1
                skip-ws()

                if i < n && (chars[i] == '"' || chars[i] == "'") {
                    let quote = chars[i]
                    i += 1
                    let buf = ''
                    while i < n && chars[i] != quote {
                        buf += chars[i]
                        i += 1
                    }
                    if i < n && chars[i] == quote { i += 1 }
                    val = buf
                } else {
                    let buf = ''
                    while i < n && chars[i] != ']' {
                        if !is-space(chars[i]) { buf += chars[i] }
                        i += 1
                    }
                    val = buf
                }
            }

            while i < n && chars[i] != ']' { i += 1 }
            if i < n && chars[i] == ']' { i += 1 }

            if val != nil {
                let v = val ?? ''
                preds.push("@{name}={xpath-literal(v)}")
            } else if name != '' {
                preds.push("@{name}")
            }

            continue
        }

        i += 1
    }

    if #preds == 0 {
        return tagname
    }

    "{tagname}[{preds.join(' and ')}]"
}

fn tokenize-selector(selector: String) -> Array[(String, String)] {
    let chars = selector.chars()
    let n = #chars
    let out = []
    let comb = ' '
    let buf = ''
    let depth = 0
    let quote = ''

    fn flush() {
        let simple = buf.strip()
        if simple != '' {
            out.push((comb, simple))
            buf = ''
            comb = ' '
        } else {
            buf = ''
        }
    }

    for i in ..n {
        let ch = chars[i]

        if quote != '' {
            buf += ch
            if ch == quote { quote = '' }
            continue
        }

        if ch == '"' || ch == "'" {
            quote = ch
            buf += ch
            continue
        }

        if ch == '[' {
            depth += 1
            buf += ch
            continue
        }

        if ch == ']' {
            depth -= 1
            buf += ch
            continue
        }

        if depth == 0 && ch == '>' {
            flush()
            comb = '>'
            continue
        }

        if depth == 0 && is-space(ch) {
            if buf != '' {
                flush()
            }
            continue
        }

        buf += ch
    }

    flush()
    out
}

fn split-groups(selector: String) -> Array[String] {
    let chars = selector.chars()
    let n = #chars
    let i = 0
    let buf = ''
    let out = []
    let depth = 0
    let quote = ''

    while i < n {
        let ch = chars[i]

        if quote != '' {
            buf += ch
            if ch == quote { quote = '' }
            i += 1
            continue
        }

        if ch == '"' || ch == "'" {
            quote = ch
            buf += ch
            i += 1
            continue
        }

        if ch == '[' {
            depth += 1
            buf += ch
            i += 1
            continue
        }

        if ch == ']' {
            depth -= 1
            buf += ch
            i += 1
            continue
        }

        if ch == ',' && depth == 0 {
            let part = buf.strip()
            if part != '' { out.push(part) }
            buf = ''
            i += 1
            continue
        }

        buf += ch
        i += 1
    }

    let tail = buf.strip()
    if tail != '' { out.push(tail) }

    out
}

fn css-to-xpath(selector: String) -> String {
    let s = selector.strip()
    if s == '' { return '' }

    if s.starts?('/') || s.starts?('./') {
        return s
    }

    let groups = split-groups(s)
    let xpaths = []

    for group in groups {
        let tokens = tokenize-selector(group)
        if (#tokens == 1) && group.match?(/>/) {
            let parts = group.split('>').map(\_.strip()).filter(\_ != '')
            tokens = []
            for i in ..#parts {
                tokens.push(((i == 0) ? ' ' : '>', parts[i]))
            }
        }
        let xp = ''

        for i in ..#tokens {
            let (comb, simple) = tokens[i]
            let seg = parse-simple-selector(simple)
            let axis = if i == 0 {
                '//'
            } else if comb == '>' {
                '/'
            } else {
                '//'
            }
            xp = "{xp}{axis}{seg}"
        }

        if xp != '' { xpaths.push(xp) }
    }

    xpaths.join(' | ')
}

fn strip-tags(html: String) -> String {
    html.sub(/<[^>]+>/, ' ').sub(/\s+/, ' ').strip()
}

fn escape-text(s: String) -> String {
    s.sub('&', '&amp;')
     .sub('<', '&lt;')
     .sub('>', '&gt;')
     .sub('"', '&quot;')
     .sub("'", '&#39;')
     .sub(/[\N{U+0000}-\N{U+001F}\N{U+007F}-\N{U+FFFF}]/u, [_, ch] -> "&#{ord(ch)};")
}

fn unescape-text(s: String) -> String {
    s.sub(/&#x([0-9A-Fa-f]+);/, [_, hex] -> chr(int(hex, 16)))
     .sub(/&#(\d+);/, [_, dec] -> chr(int(dec)))
     .sub('&lt;', '<')
     .sub('&gt;', '>')
     .sub('&quot;', '"')
     .sub('&#39;', "'")
     .sub('&amp;', '&')
}

fn node-text(node: xml.XMLNode) -> String {
    unescape-text(strip-tags(node.outerXML))
}

fn parse-fragment(markup: String) -> xml.Document {
    let buf = Blob()
    buf.push("<root>")
    buf.push(markup)
    buf.push("</root>")
    buf.push(0)
    xml.parse(buf, nil, nil, xml.XML_PARSE_NOBLANKS)
}

fn is-descendant(node: xml.XMLNode, ancestor: xml.XMLNode, include-self: Bool = false) -> Bool {
    for let cur = include-self ? node : node.parent; cur != nil; cur = cur.parent {
        if cur == ancestor { return true }
    }
    false
}

class Selection : Iterable[Element] {
    __doc: xml.Document
    __nodes: Array[xml.XMLNode]

    init(doc: xml.Document, nodes: ?Array[xml.XMLNode]) {
        __doc = doc
        __nodes = nodes ?? []
    }

    #() -> Int {
        #__nodes
    }

    count -> Int { #__nodes }

    [](index: Int) -> Element {
        Element(__doc, __nodes[index])
    }

    first() -> ?Element {
        (#__nodes > 0) ? Element(__doc, __nodes[0]) : nil
    }

    last() -> ?Element {
        (#__nodes > 0) ? Element(__doc, __nodes[-1]) : nil
    }

    attr(name: String) -> String | nil {
        if let $t = first() { t[name] }
    }

    text() -> String {
        __nodes.map(n -> node-text(n)).join(' ').strip()
    }

    select(css: String) -> Selection {
        let xpath = css-to-xpath(css)
        let nodes = [*__doc.select(xpath)]
        let filtered = [n for n in nodes if __nodes.any?(base -> is-descendant(n, base, false))]
        Selection(__doc, filtered)
    }

    find(css: String) -> ?Element {
        select(css).first()
    }

    find-all(css: String) -> Selection {
        select(css)
    }

    filter(pred: Element -> Any) -> Selection {
        Selection(__doc, __nodes.filter(n -> pred(Element(__doc, n))))
    }

    __iter__() -> Iter[Element] {
        [Element(__doc, node) for node in __nodes].__iter__()
    }
}

class Element : Iterable[Element] {
    __doc: xml.Document
    __node: xml.XMLNode

    init(doc: xml.Document, node: xml.XMLNode) {
        __doc = doc
        __node = node
    }

    name -> String { __node.name }
    node() -> xml.XMLNode { __node }
    text -> String { node-text(__node) }
    text=(val: String) -> String {
        clear()
        let doc = parse-fragment(escape-text(val))
        for child in doc.root.children {
            __node.addChild(child)
        }
        val
    }
    inner-html -> String {
        [child.outerXML for child in __node.children].join('')
    }
    outer-html -> String { __node.outerXML }
    html -> String { inner-html }
    html=(val: String) -> String {
        clear()
        append-html(val)
        val
    }

    attrs -> Dict[String, String] { __node.props.dict }

    attr(key: String) -> String | nil { __node.props[key] }
    [](key: String) -> String | nil { __node.props[key] }
    []=(key: String, val: String) -> String { __node.props[key] = val }

    has-attr(key: String) -> Bool {
        __node.props.contains?(key)
    }

    remove-attr(key: String) -> String | nil {
        __node.props.delete(key)
    }

    id -> String | nil { self['id'] }
    id=(val: String) -> String { self['id'] = val }

    classes -> Array[String] {
        (self['class'] ?? '').words()
    }

    has-class(name: String) -> Bool {
        name in classes
    }

    add-class(name: String) {
        let existing = classes
        if name not in existing {
            existing.push(name)
            self['class'] = existing.join(' ')
        }
    }

    remove-class(name: String) {
        let xs = classes.filter(\_ != name)
        if #xs == 0 {
            remove-attr('class')
        } else {
            self['class'] = xs.join(' ')
        }
    }

    toggle-class(name: String) {
        if has-class(name) {
            remove-class(name)
        } else {
            add-class(name)
        }
    }

    parent -> ?Element {
        if let $p = __node.parent { Element(__doc, p) }
    }

    next -> ?Element {
        if let $p = __node.next { Element(__doc, p) }
    }

    prev -> ?Element {
        if let $p = __node.prev { Element(__doc, p) }
    }

    children* -> Generator[Element] {
        for child in __node.children {
            yield Element(__doc, child)
        }
    }

    select(css: String) -> Selection {
        let xpath = css-to-xpath(css)
        let nodes = [*__doc.select(xpath)]
        let filtered = [n for n in nodes if is-descendant(n, __node, false)]
        Selection(__doc, filtered)
    }

    find(css: String) -> ?Element {
        select(css).first()
    }

    find-all(css: String) -> Selection {
        select(css)
    }

    remove() {
        __node.unlink()
    }

    clear() {
        let kids = [*__node.children]
        for child in kids { child.unlink() }
    }

    append-html(markup: String) {
        let doc = parse-fragment(markup)
        for child in doc.root.children {
            __node.addChild(child)
        }
    }

    unwrap() {
        if let $p = __node.parent {
            let kids = [*__node.children]
            for child in kids {
                p.addChild(child)
            }
            __node.unlink()
        }
    }

    __iter__() -> Generator[Element] {
        children
    }
}

class Html {
    __doc: xml.Document

    init(doc: xml.Document) {
        __doc = doc
    }

    root -> Element { Element(__doc, __doc.root) }
    text -> String { node-text(__doc.root) }

    select(css: String) -> Selection {
        let xpath = css-to-xpath(css)
        Selection(__doc, [*__doc.select(xpath)])
    }

    select-one(css: String) -> ?Element {
        select(css).first()
    }

    select-all(css: String) -> Selection {
        select(css)
    }

    find(css: String) -> ?Element {
        select(css).first()
    }

    find-all(css: String) -> Selection {
        select(css)
    }

    [](css: String) -> Selection {
        select(css)
    }

    dump(dest: ?(String | Path) = nil) -> String {
        let out = __doc.root.outerXML
        if let $d = dest {
            Path(d).write(out)
        }
        out
    }
}

pub fn parse(
    doc: String | Blob,
    url: ?String = nil,
    encoding: ?String = nil,
    options: Int = xml.XML_PARSE_NOBLANKS
) -> Html {
    Html(xml.parse(doc, url, encoding, options))
}

pub fn read(
    path: String,
    encoding: ?String = nil,
    options: Int = xml.XML_PARSE_NOBLANKS
) -> Html {
    Html(xml.read(path, encoding, options))
}

pub fn html(parts: Array[Any]) -> Html {
    let cooked = []

    for match parts {
        str: String => {
            cooked.push(str)
        },

        t: Element => {
            cooked.push((t.node(), nil))
        },

        s: Html => {
            cooked.push((s.root.node(), nil))
        },

        n: xml.XMLNode => {
            cooked.push((n, nil))
        },

        (s: String, *) => {
            cooked.push((escape-text(s), nil))
        },

        (t: Element, *) => {
            cooked.push((t.node(), nil))
        },

        (s: Html, *) => {
            cooked.push((s.root.node(), nil))
        },

        (n: xml.XMLNode, *) => {
            cooked.push((n, nil))
        },

        (x, *) => {
            cooked.push((x, nil))
        }
    }

    Html(xml.xml(cooked))
}

@test
fn test-basic-find-and-text() {
    let doc = '''
<!DOCTYPE html>
<html>
  <head>
    <title>Example</title>
  </head>
  <body>
    <div id="main" class="c1 c2" data-role="page">
      Hello <b>World</b>
      <ul class="items">
        <li class="item" data-id="1">One</li>
        <li class="item" data-id="2"><span>Two</span></li>
      </ul>
    </div>
    <a class="btn primary" href="/x" data-x="1">X</a>
    <a class="btn" href="/y">Y</a>
  </body>
</html>
'''

    let soup = parse(doc)
    if let $main = soup.find('#main') {
        assert(main.text == 'Hello World One Two', 'text extraction')
    } else {
        assert(false, 'missing #main')
    }
    if let $b = soup.find('b') {
        assert(b.text == 'World', 'nested find')
    } else {
        assert(false, 'missing <b>')
    }
    assert(soup.select('li.item').text() == 'One Two', 'selection text')
}

@test
fn test-selectors-and-attrs() {
    let doc = '''
<!DOCTYPE html>
<html>
  <body>
    <div class="c1 c2" data-role="page"></div>
    <a class="btn primary" href="/x" data-x="1">X</a>
  </body>
</html>
'''
    let soup = parse(doc)
    assert(soup.select('div.c1').count == 1, 'class selector works')
    assert(soup.select('div[data-role="page"]').count == 1, 'attr selector works')
    assert(soup.select('a.btn')[0]['href'] == '/x', 'attr access works')
    assert(soup.select('//a[@data-x]').count == 1, 'xpath passthrough works')
}

@test
fn test-group-and-child-selectors() {
    let doc = '''
<!DOCTYPE html>
<html>
  <body>
    <div><a class="btn" href="/x">X</a></div>
    <span id="y">Y</span>
  </body>
</html>
'''
    let soup = parse(doc)
    assert(soup.select('a.btn, #y').count == 2, 'group selector works')
    assert(soup.select('div > a').count == 1, 'child selector works')
}

@test
fn test-tag-scoped-find() {
    let doc = '''
<!DOCTYPE html>
<html>
  <body>
    <div class="wrap"><a href="/x">X</a></div>
    <a href="/y">Y</a>
  </body>
</html>
'''
    let soup = parse(doc)
    if let $div = soup.find('div.wrap') {
        assert(div.find-all('a').count == 1, 'scoped find_all filters descendants')
    } else {
        assert(false, 'missing div.wrap')
    }
    assert(soup.select('div.wrap').select('a').count == 1, 'selection chaining')
}

@test
fn test-class-and-attr-helpers() {
    let doc = '''
<!DOCTYPE html>
<html>
  <body>
    <a class="btn primary" href="/x">X</a>
  </body>
</html>
'''
    let soup = parse(doc)
    if let $a = soup.find('a') {
        assert(a.has-class('btn'), 'has-class')
        a.add-class('active')
        assert(a.has-class('active'), 'add-class')
        a.remove-class('primary')
        assert(!a.has-class('primary'), 'remove-class')
        a.toggle-class('active')
        assert(!a.has-class('active'), 'toggle-class off')
        a.toggle-class('active')
        assert(a.has-class('active'), 'toggle-class on')
        assert(a.has-attr('href'), 'has-attr')
        assert(a.remove-attr('href') == '/x', 'remove-attr')
        assert(a['href'] == nil, 'attr removed')
    } else {
        assert(false, 'missing <a>')
    }
}

@test
fn test-remove-and-unwrap() {
    let doc = '''
<!DOCTYPE html>
<html>
  <body>
    <div><span>One</span><span>Two</span></div>
    <p>Keep</p>
  </body>
</html>
'''
    let soup = parse(doc)
    if let $span = soup.find('span') {
        span.remove()
    } else {
        assert(false, 'missing <span>')
    }
    assert(soup.select('span').count == 1, 'remove')
    if let $div = soup.find('div') {
        div.unwrap()
    } else {
        assert(false, 'missing <div>')
    }
    assert(soup.select('div').count == 0, 'unwrap removes tag')
    assert(soup.select('span').count == 1, 'unwrap keeps children')
}

@test
fn test-selection-chaining-and-filter() {
    let doc = '''
<!DOCTYPE html>
<html>
  <body>
    <section id="a"><p class="note">A1</p><p>A2</p></section>
    <section id="b"><p class="note">B1</p><p>B2</p></section>
  </body>
</html>
'''
    let soup = parse(doc)
    let sections = soup.select('section')
    assert(sections.count == 2, 'two sections')
    assert(sections.select('p.note').count == 2, 'selection.select across bases')
    let onlyA = sections.filter(t -> t['id'] == 'a')
    assert(onlyA.select('p').count == 2, 'filter keeps one base')
    assert(onlyA.select('p.note').text() == 'A1', 'filtered selection text')
}

@test
fn test-attr-selectors-and-existence() {
    let doc = '''
<!DOCTYPE html>
<html>
  <body>
    <input type="text" disabled="disabled" />
    <input type="password" />
    <div data-x="1" data-y="two"></div>
  </body>
</html>
'''
    let soup = parse(doc)
    assert(soup.select('input[disabled]').count == 1, 'attr existence')
    assert(soup.select('input[type="password"]').count == 1, 'quoted attr equals')
    assert(soup.select('div[data-x="1"]').count == 1, 'attr equals')
    assert(soup.select('div[data-y="two"]').count == 1, 'quoted attr equals 2')
}

@test
fn test-grouping-and-last-first-attr() {
    let doc = '''
<!DOCTYPE html>
<html>
  <body>
    <a class="btn" href="/a">A</a>
    <a class="btn" href="/b">B</a>
    <span id="x">X</span>
  </body>
</html>
'''
    let soup = parse(doc)
    let links = soup.select('a.btn')
    assert(links.first().attr('href') == '/a', 'first attr')
    assert(links.last().attr('href') == '/b', 'last attr')
    assert(soup.select('a.btn, #x').count == 3, 'grouping works')
}

@test
fn test-text-normalization-and-scoping() {
    let doc = '''
<!DOCTYPE html>
<html>
  <body>
    <div id="wrap">
      <span> Alpha </span>
      <span>Beta</span>
      <div><span>Gamma</span></div>
    </div>
  </body>
</html>
'''
    let soup = parse(doc)
    if let $wrap = soup.find('#wrap') {
        assert(wrap.text == 'Alpha Beta Gamma', 'normalized text')
        assert(wrap.find-all('span').count == 3, 'scoped find_all')
        assert(soup.select('#wrap > div > span').text() == 'Gamma', 'child selector global')
    } else {
        assert(false, 'missing #wrap')
    }
}

@test
fn test-css-to-xpath-child() {
    assert(css-to-xpath('#wrap > div > span') == '//*[@id=\'wrap\']/div/span', 'child combinator xpath')
}

@test
fn test-large-document() {
    let parts = ['<!DOCTYPE html><html><body>']
    for i in ..2500 {
        parts.push("<div class=\"item\" data-i=\"{i}\"><span>Item {i}</span></div>")
    }
    parts.push('</body></html>')
    let doc = parts.join('')
    let soup = parse(doc)
    assert(soup.select('div.item').count == 2500, 'large doc class selector')
    assert(soup.select('div > span').count == 2500, 'large doc child selector')
    assert(soup.select('div[data-i=\"42\"]').count == 1, 'large doc attr selector')
}

@test
fn test-selector-fuzz-deterministic() {
    let doc = '''
<!DOCTYPE html>
<html>
  <body>
    <div id="a" class="c1"><span class="c2">A</span></div>
    <section id="b" class="c2"><p class="c1">B</p></section>
    <div id="c" class="c3" data-x="1"><a class="c1 c2" href="/x">C</a></div>
    <p id="d" data-x="2">D</p>
  </body>
</html>
'''
    let soup = parse(doc)
    let tags = ['div', 'section', 'p', 'span', 'a']
    let classes = ['c1', 'c2', 'c3']
    let ids = ['a', 'b', 'c', 'd']
    let attrs = ['data-x']
    let values = ['1', '2']

    let seed = 1337
    fn next-int(n: Int) -> Int {
        seed = (seed * 1103515245 + 12345) % 2147483647
        seed % n
    }

    for _ in ..200 {
        let kind = next-int(5)
        let sel = match kind {
            0 => tags[next-int(#tags)],
            1 => "#{ids[next-int(#ids)]}",
            2 => "{tags[next-int(#tags)]}.{classes[next-int(#classes)]}",
            3 => "{tags[next-int(#tags)]}[{attrs[0]}=\"{values[next-int(#values)]}\"]",
            _ => "{tags[next-int(#tags)]} > {tags[next-int(#tags)]}"
        }

        let xpath = css-to-xpath(sel)
        assert(soup.select(sel).count == soup.select(xpath).count, "fuzz selector {sel}")
    }
}

@test
fn test-mutation-heavy() {
    let doc = '''
<!DOCTYPE html>
<html>
  <body>
    <ul id="list">
      <li class="keep">A</li>
      <li class="rm">B</li>
      <li class="rm">C</li>
      <li class="keep">D</li>
    </ul>
    <div class="wrap"><span>Inner</span></div>
  </body>
</html>
'''
    let soup = parse(doc)
    for li in soup.select('li.rm') {
        li.remove()
    }
    assert(soup.select('li').count == 2, 'removed items')
    if let $wrap = soup.find('div.wrap') {
        wrap.unwrap()
    } else {
        assert(false, 'missing wrap')
    }
    assert(soup.select('div.wrap').count == 0, 'unwrap removed wrapper')
    assert(soup.select('span').count == 1, 'unwrap preserved child')
}

@test
fn test-text-and-html-mutation() {
    let doc = '''
<!DOCTYPE html>
<html>
  <body>
    <div id="t">X</div>
    <div id="h"><span>Old</span></div>
  </body>
</html>
'''
    let soup = parse(doc)
    if let $t = soup.find('#t') {
        t.text = '<b>Bold</b> & "quotes"'
        assert(t.text == '<b>Bold</b> & "quotes"', 'text= escapes markup')
        assert(t.inner-html == '&lt;b&gt;Bold&lt;/b&gt; &amp; "quotes"', 'text= inner-html')
    } else {
        assert(false, 'missing #t')
    }

    if let $h = soup.find('#h') {
        h.html = '<em>New</em><span>Text</span>'
        assert(h.select('em').count == 1, 'html= sets new children')
        h.append-html('<b>More</b>')
        assert(h.select('b').count == 1, 'append-html adds child')
        h.clear()
        assert(h.inner-html == '', 'clear removes children')
    } else {
        assert(false, 'missing #h')
    }
}

@test
fn test-dump-to-string-and-file() {
    let doc = '''
<!DOCTYPE html>
<html>
  <body>
    <div id="x"><span>Hi</span></div>
  </body>
</html>
'''
    let soup = parse(doc)
    let out = soup.dump()
    assert(out.match?(/<div id="x">/), 'dump to string')
    with p = Path.temp() {
        soup.dump(p)
        assert(p.read-text() == out, 'dump to file')
    }
}

@test
fn test-html-literal-and-interpolation() {
    let soup = html"<div class=\"x\">Hello</div>"
    assert(soup.find('div').text == 'Hello', 'html literal basic')

    let raw = "<span>Raw</span>"
    let escaped = html"<section>{raw}</section>"
    assert(escaped.select('span').count == 0, 'interpolated string escaped')
    assert(escaped.find('section').text == '<span>Raw</span>', 'escaped text preserved')

    let base = html"<div><span>Hi</span></div>"
    let more = html"<section>{base}</section>"
    assert(more.select('span').count == 1, 'soup interpolation')
    assert(more.find('span').text == 'Hi', 'soup interpolation content')

    let base2 = html"<div><span>Hi</span></div>"
    if let $elt = base2.find('span') {
        let more2 = html"<p>{elt}</p>"
        assert(more2.find('p').text == 'Hi', 'tag interpolation')
    } else {
        assert(false, 'missing span for tag interpolation')
    }
}
