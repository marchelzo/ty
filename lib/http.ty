import llhttp (..)
import os (..)
import json
import errno
import net
import log

pub fn urlDecode(s: String) -> String {
    s.sub('+', ' ')
     .sub(/%[[:xdigit:]]{2}/, \chr(int(_[1;], 16)))
     .sub("\r\n", "\n")
     .sub("\r", "\n")
}

pub fn decodeQuery(query: String) {
    let params = %{}

    for [k, ?v] in query.split('&').map(&split('=', 1) |> &map(urlDecode)) {
        if let $p = params[k] {
            if p :: Array {
                p.push(v)
            } else {
                params[k] = [p, v]
            }
        } else {
            params[k] = v
        }
    }

    return params
}

fn makePattern(route) {
    let route = route.sub(/<(\w+)>/, [_, name] -> "<{name}:\\w+>")
    let params = route.matches(/<(\w+):/).map(&1)
    return (params, regex('^' + route.sub(/<\w+:(.*?)>/, [_, pattern] -> "({pattern})") + '/?$'))
}

class HttpResponse {
    statusCode: Int
    body:       Blob
    headers:    Dict[String, String]

    init() {
        statusCode = HTTP_STATUS_OK
        body = Blob()
        headers = %{'Content-Type': 'text/html'}
    }

    header(k, v) {
        if v == nil {
            headers[k]
        } else {
            headers[k] = "{v}"
        }
    }

    status(c) {
        statusCode = (c ?? statusCode)
    }

    write(s) {
        body.push(s)
    }

    json(x) {
        body.push(json::encode(x))
        header('Content-Type', 'application/json')
    }

    plain(x) {
        body.push("{x}")
        header('Content-Type', 'text/plain')
    }

    send(c) {
        let response = Blob([
            "HTTP/1.1 {statusCode} {statusName(statusCode)}",
            "Content-Length: {#body}",
            *["{k}: {v}" for k, v in headers],
            '',
            ''
        ].join('\r\n'))

        response.push(body)

        ::write(c, response, all=true)
    }
}

use HttpRequest = HttpMessage & {
    addr: ?Blob,
    params: Dict[String, String | [String]]
}

use RequestHandler = {req: HttpRequest, rsp: HttpResponse, params: *_} -> Int;

use RouteMap = Dict[
    String,
    Array[{
        route: String,
        params: Array[String],
        pattern: Regex,
        fun: RequestHandler
    }]
];

use ClientConnection = {
    fd:   Int,
    addr: Blob,
    p:    HttpParser
};

class HttpServer {
    static __routes: RouteMap

    __sock:     Int
    __conns:    Array[ClientConnection]
    __stopping: Bool
    __handlers: RouteMap

    init(*args, backlog: Int = 64) {
        __conns    = []
        __stopping = false
        __handlers = %{*: []}

        for method, handlers in __routes {
            __handlers[method] = handlers.map(handler -> {
                *handler,
                fun: handler.fun.bind(self)
            })
        }

        match args {
            [addr: String, port: Int] => {
                __sock = net::listen('tcp', "{addr}:{port}", backlog)
            },

            [sock: Int] => {
                __sock = sock
                listen(__sock, backlog)
            }
        }
    }

    static __init_subclass__() {
        __routes = %{*: []}

        for _, method in self.__methods__ {
            if method.__class__ != self {
                continue
            }

            if not let $route = method.?__route {
                continue
            }

            __install(
                route.method,
                route.route,
                method
            )
        }
    }

    address -> (String, String) {
        getnameinfo(
            getsockname(__sock),
            NI_NUMERICHOST | NI_NUMERICSERV
        )
    }

    __resolve(
        method: String,
        url: String
    ) -> (RequestHandler, Dict[String, String]) | nil {
        if not let $handlers = __handlers[method] {
            return nil
        }

        for {params, pattern, fun, *} in handlers {
            if let $m = url.match(pattern) {
                return (fun, %{params[i]: m[i + 1] for i in ..#params})
            }
        }
    }

    stop() { __stopping = true }

    static __install(method: String, route: String, f: RequestHandler) {
        let (params, pattern) = makePattern(route)
        let handlers = __routes[method]
        handlers.push({
            route,
            params,
            pattern,
            fun: f
        })
        handlers.sort!(by=\-(_.route.search('<') ?? 99999))
    }

    static get(f, route) {
        f.__route = {method: 'GET', route}
        f
    }

    static post(f, route) {
        f.__route = {method: 'POST', route}
        f
    }

    static delete(f, route) {
        f.__route = {method: 'DELETE', route}
        f
    }

    static put(f, route) {
        f.__route = {method: 'PUT', route}
        f
    }

    run() {
        let b = Blob()

        while !__stopping {
            log::debug!("poll()")

            if not let Ok(pollFds) = poll([__sock, *__conns.map(\_.fd)], -1) {
                continue
            }

            for (fd, ev) in pollFds {
                if fd == __sock {
                    if ev & POLLIN {
                        let (conn, addr) = accept(fd)
                        __conns.push({fd: conn, addr, p: HttpParser(HTTP_REQUEST)})
                        log::debug!("new connection: fd={conn} addr={getnameinfo(addr, NI_NUMERICHOST | NI_NUMERICSERV)}")
                    }
                } else {
                    let c: ClientConnection = __conns.find(${it.fd == fd})!
                    if (ev & POLLIN) && read(fd, b, 4096) > 0 {
                        log::debug!("read {#b} bytes from fd={fd}")

                        c.p.push(b)
                        b.clear()

                        for req in c.p.takeMessages() {
                            let rsp = HttpResponse()

                            let u = req.url
                            let [url, ?query] = req.url.split('?', 1)
                            let params = %{}

                            log::debug!("{getnameinfo(c.addr, NI_NUMERICHOST | NI_NUMERICSERV)}: {req.method} {u}")

                            if query != nil {
                                params.update(decodeQuery(query))
                            }

                            match (req.headers['Content-Type'], req.?body.str!()) {
                                (/^multipart\/form-data/, $body) => {
                                    let form = %{}
                                    let offset = 0
                                    if not let [_, delim] = body.match(/^(.*)\r\n/) {
                                        RuntimeError("")
                                    }

                                    while let $i = body.bsearch(delim, offset) {
                                        if not let $j = body.bsearch('\r\n\r\n', i) {
                                            break
                                        }
                                        let headers = body.bsplice(i + #delim + 2, j).split(/\r\n/)
                                        offset = body.bsearch(delim, j)
                                        let content = body.bsplice(j + 4, offset - 2)
                                        let headers = %{k.lower(): v for [k, v] in headers.map(&split(': ', 1))}
                                        let disposition = %{k: v for [_, k, v] in headers['content-disposition'].matches(/(\w+)="([^"]+)"/)}
                                        let name = disposition['name']

                                        if let $filename = disposition['filename'] {
                                            let f = {
                                                name: filename,
                                                type: headers['content-type'],
                                                content: Blob(content)
                                            }
                                            if let $fs = form[name] {
                                                fs.push(f)
                                            } else {
                                                form[name] = [f]
                                            }
                                        } else {
                                            form[disposition['name']] = content
                                        }
                                    }
                                    params.update(form)
                                },

                                (/^application\/x-www-form-urlencoded/, $body) => {
                                    params.update(decodeQuery(body))
                                },

                                _ => {}
                            }

                            if let $m = req.method and let (f, ps) = __resolve(m, url) {
                                try {
                                    rsp.status(f({*req, url, params, addr=c.addr}, rsp, **ps) ?? 200)
                                } catch e {
                                    rsp.plain("Exception: {e}\n\nBacktrace:\n{str(e.trace())}")
                                    rsp.status(500)
                                }
                            } else {
                                rsp.status(404)
                            }

                            rsp.send(fd)
                        }
                    } else {
                        close(fd)
                        __conns.filter!(\_.fd != fd)
                    }
                }
            }
        }
    }
}
