#!/usr/bin/env ty

import llhttp (..)
import os (..)
import json
import errno
import net
import log

log::logging({level: log::DEBUG})

function urlDecode(s: String) -> String {
    s.sub('+', ' ')
     .sub(/%../, s -> chr(int(s.slice(1), 16)))
     .sub("\r\n", "\n")
     .sub("\r", "\n")
}

function decodeQuery(query: String) {
    let params = %{}

    for [k, ?v] in query.split('&').map(&split('=', 1) |> &map(urlDecode)) {
        if let $p = params[k] {
            if p :: Array {
                p.push(v)
            } else {
                params[k] = [p, v]
            }
        } else {
            params[k] = v
        }
    }

    return params
}

function makePattern(route) {
    let route = route.sub(/<(\w+)>/, [_, name] -> "<{name}:\\w+>")
    let params = route.matches(/<(\w+):/).map(&1)
    return (params, regex('^' + route.sub(/<\w+:(.*?)>/, [_, pattern] -> "({pattern})") + '/?$'))
}

class HttpResponse {
    statusCode: Int
    body:       Blob
    headers:    Dict[String, String]

    init() {
        statusCode = HTTP_STATUS_OK
        body = Blob()
        headers = %{'Content-Type': 'text/html'}
    }

    header(k, v) {
        if v == nil {
            headers[k]
        } else {
            headers[k] = "{v}"
        }
    }

    status(c) {
        statusCode = (c ?? statusCode)
    }

    write(s) {
        body.push(s)
    }

    json(x) {
        body.push(json::encode(x))
        self.header('Content-Type', 'application/json')
    }

    plain(x) {
        body.push("{x}")
        self.header('Content-Type', 'text/plain')
    }

    send(c) {
        let response = Blob([
            "HTTP/1.1 {statusCode} {statusName(statusCode)}",
            "Content-Length: {#body}",
            *["{k}: {v}" for k, v in headers],
            '',
            ''
        ].join('\r\n'))

        response.push(body)

        ::write(c, response, all=true)
    }
}

use HttpRequest = HttpMessage & {
    addr: ?Blob,
    params: Dict[String, String | [String]]
}

use RequestHandler = {req: HttpRequest, rsp: HttpResponse, params: *_} -> Int;

use RouteMap = Dict[
    String,
    Array[{
        route: String,
        params: Array[String],
        pattern: Regex,
        fun: RequestHandler
    }]
];

class HttpServer {
    __sock:     Int
    __conns:    Array[{fd: Int, p: HttpParser}]
    __handlers: RouteMap
    __stopping: Bool

    init(*args, backlog: Int = 64) {
        __handlers = %{*:[]}
        __conns = []
        __stopping = false
        match args {
            [addr: String, port: Int] => {
                __sock = net::listen('tcp', "{addr}:{port}", backlog)
            },

            [sock: Int] => {
                __sock = sock
                listen(__sock, backlog)
            }
        }
    }

    address -> (String, String) {
        getnameinfo(
            getsockname(__sock),
            NI_NUMERICHOST | NI_NUMERICSERV
        )
    }

    findHandler(method: String, url: String) -> (RequestHandler, Dict[String, String]) | nil {
        if not let $hs = __handlers[method] {
            return nil
        }

        for {params: ps, pattern, fun, *} in hs {
            if let $m = url.match!(pattern) {
                return (fun, %{ps[i]: m[i+1] for i in ..#ps})
            }
        }
    }

    stop() { __stopping = true }

    __install(method: String, route: String, f: RequestHandler) {
        let (params, pattern) = makePattern(route)

        __handlers[method].push({
            route,
            params,
            pattern,
            fun: f
        })

        __handlers[method].sort!(by=\-(_.route.search('<') ?? 99999))
    }

    get(route, f) {
        __install('GET', route, f)
    }

    post(route, f) {
        __install('POST', route, f)
    }

    delete(route, f) {
        __install('DELETE', route, f)
    }

    put(route, f) {
        __install('PUT', route, f)
    }

    run() {
        let b = Blob()

        while !__stopping {
            log::debug!("poll()")

            if not let Ok(pollFds) = poll([__sock, *__conns.map(\_.fd)], -1) {
                continue
            }

            for (fd, ev) in pollFds {
                if fd == __sock {
                    if ev & POLLIN {
                        let (conn, addr) = accept(fd)
                        __conns.push({fd: conn, addr, p: HttpParser(HTTP_REQUEST)})
                        log::debug!("new connection: fd={conn} addr={getnameinfo(addr, NI_NUMERICHOST | NI_NUMERICSERV)}")
                    }
                } else {
                    let $c = __conns.find(${it.fd == fd})
                    if (ev & POLLIN) && read(fd, b, 4096) > 0 {
                        log::debug!("read {#b} bytes from fd={fd}")

                        c.p.push(b)
                        b.clear()

                        for req in c.p.takeMessages() {
                            let rsp = HttpResponse()

                            let u = req.url
                            let [url, ?query] = req.url.split('?', 1)
                            let params = %{}

                            log::debug!("{getnameinfo(c.addr, NI_NUMERICHOST | NI_NUMERICSERV)}: {req.method} {u}")

                            if query != nil {
                                params.update(decodeQuery(query))
                            }

                            match (req.headers['Content-Type'], req.?body.str!()) {
                                (/^multipart\/form-data/, $body) => {
                                    let form = %{}
                                    let offset = 0
                                    if not let [_, delim] = body.match!(/^(.*)\r\n/) {
                                        RuntimeError("")
                                    }

                                    while let $i = body.bsearch(delim, offset) {
                                        if not let $j = body.bsearch('\r\n\r\n', i) {
                                            break
                                        }
                                        let headers = body.bsplice(i + #delim + 2, j).split(/\r\n/)
                                        offset = body.bsearch(delim, j)
                                        let content = body.bsplice(j + 4, offset - 2)
                                        let headers = %{k.lower(): v for [k, v] in headers.map(&split(': ', 1))}
                                        let disposition = %{k: v for [_, k, v] in headers['content-disposition'].matches(/(\w+)="([^"]+)"/)}
                                        let name = disposition['name']

                                        if let $filename = disposition['filename'] {
                                            let f = {
                                                name: filename,
                                                type: headers['content-type'],
                                                content: Blob(content)
                                            }
                                            if let $fs = form[name] {
                                                fs.push(f)
                                            } else {
                                                form[name] = [f]
                                            }
                                        } else {
                                            form[disposition['name']] = content
                                        }
                                    }
                                    params.update(form)
                                },

                                (/^application\/x-www-form-urlencoded/, $body) => {
                                    params.update(decodeQuery(body))
                                },

                                _ => {}
                            }

                            if let $m = req.method and let (f, ps) = self.findHandler(m, url) {
                                try {
                                    rsp.status(f({*req, url, params, addr: c.addr}, rsp, **ps) ?? 200)
                                } catch e {
                                    rsp.header('Content-Type', 'text/plain')
                                    rsp.write("Exception: {e}")
                                    rsp.status(500)
                                }
                            } else {
                                rsp.status(404)
                            }

                            rsp.send(fd)
                        }
                    } else {
                        close(fd)
                        __conns.filter!(\_.fd != fd)
                    }
                }
            }
        }
    }
}
