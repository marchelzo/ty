#!/usr/bin/env ty

import llhttp (..)
import os (..)
import json
import errno

function urlDecode(s: String) -> String {
    s.sub('+', ' ')
     .sub(/%../, s -> chr(int(s.slice(1), 16)))
     .sub("\r\n", "\n")
     .sub("\r", "\n")
}

function decodeQuery(query: String) {
    let params = %{}

    for [k, ?v] in query.split('&').map(&split('=') |> &map(urlDecode)) {
        if let $p = params[k] {
            if p :: Array {
                p.push(v)
            } else {
                params[k] = [p, v]
            }
        } else {
            params[k] = v
        }
    }

    return params
}

function makePattern(route) {
    let route = route.sub(/<(\w+)>/, [_, name] -> "<{name}:\\w+>")
    let params = route.matches(/<(\w+):/).map(&1)
    return (params, regex('^' + route.sub(/<\w+:(.*?)>/, [_, pattern] -> "({pattern})") + '/?$'))
}

class HttpResponse {
    init() {
        @statusCode = HTTP_STATUS_OK
        @body = Blob()
        @headers = %{'Content-Type': 'text/html'}
    }

    header(k, v) {
        if v == nil {
            @headers[k]
        } else {
            @headers[k] = "{v}"
        }
    }

    status(c) {
        @statusCode = (c ?? @statusCode)
    }

    write(s) {
        @body.push(s)
    }

    json(x) {
        @body.push(json.encode(x))
        self.header('Content-Type', 'application/json')
    }

    send(c) {
        let response = Blob([
            "HTTP/1.1 {@statusCode} {statusName(@statusCode)}",
            "Content-Length: {#@body}",
            *["{k}: {v}" for k, v in @headers],
            '',
            ''
        ].join('\r\n'))

        response.push(@body)

        ::write(c, response, all: true)
    }
}

tag SocketError;

use HttpRequest = HttpMessage & {
    addr: ?Blob,
    params: Dict[String, String | [String]]
}

use RequestHandler = (HttpRequest, HttpResponse) -> Int;

class HttpServer {
    __sock:     Int
    __conns:    Array[{fd: Int, p: HttpParser}]
    __handlers: Dict[String, Array[(Array[String], Regex, RequestHandler)]]
    __stopping: Bool

    init(*args, backlog=64) {
        __handlers = %{*:[]}
        __conns = []
        __stopping = false
        match args {
            [addr, port] => {
                __sock = socket(AF_INET, SOCK_STREAM, 0)

                setsockopt(__sock, SOL_SOCKET, SO_REUSEADDR, 1)

                let Ok([addr]) = getaddrinfo(addr, port, AF_INET, SOCK_STREAM, 0)

                let err = bind(__sock, addr)
                if err != 0 {
                    throw SocketError("bind(): {errno.str(err)}")
                }

                let err = listen(__sock, backlog)
                if err != 0 {
                    throw SocketError("listen(): {errno.str(err)}")
                }
            },

            [sock] => {
                __sock = sock
                listen(__sock, backlog)
            }
        }
    }

    findHandler(method: String, url: String) -> (RequestHandler, Dict[String, String]) | nil {
        if not let $hs = __handlers[method] {
            return nil
        }

        for (ps, pattern, f) in hs {
            if let $m = url.match!(pattern) {
                return (f, %{ps[i]: m[i+1] for i in ..#ps})
            }
        }
    }

    stop() { __stopping = true }

    get(route, f) {
        __handlers['GET'].push({*makePattern(route), f})
    }

    post(route, f) {
        __handlers['POST'].push({*makePattern(route), f})
    }

    delete(route, f) {
        __handlers['DELETE'].push({*makePattern(route), f})
    }

    put(route, f) {
        __handlers['PUT'].push({*makePattern(route), f})
    }

    run() {
        let b = Blob()

        while !__stopping {
            if not let Ok(pollFds) = poll([__sock, *__conns.map(\_.fd)], -1) {
                continue
            }

            for (fd, ev) in pollFds {
                if fd == __sock {
                    if ev & POLLIN {
                        let (conn, addr) = accept(fd)
                        __conns.push({fd: conn, addr, p: HttpParser(HTTP_REQUEST)})
                    }
                } else {
                    let $c = __conns.find(${it.fd == fd})
                    if (ev & POLLIN) && read(fd, b, 4096) > 0 {
                        c.p.push(b)
                        b.clear()

                        for req in c.p.takeMessages() {
                            let rsp = HttpResponse()

                            let u = req.url
                            let [url, ?query] = req.url.split('?', 1)
                            let params = %{}

                            if query != nil {
                                params.update(decodeQuery(query))
                            }

                            match (req.headers['Content-Type'], req.body.str!()) {
                                (/^multipart\/form-data/, $body) => {
                                    let form = %{}
                                    let offset = 0
                                    if not let [_, delim] = body.match!(/^(.*)\r\n/) {
                                        RuntimeError("")
                                    }

                                    while let $i = body.bsearch(delim, offset) {
                                        if not let $j = body.bsearch('\r\n\r\n', i) {
                                            break
                                        }
                                        let headers = body.bsplice(i + #delim + 2, j).split(/\r\n/)
                                        offset = body.bsearch(delim, j)
                                        let content = body.bsplice(j + 4, offset - 2)
                                        let headers = %{k.lower(): v for [k, v] in headers.map(&split(': ', 1))}
                                        let disposition = %{k: v for [_, k, v] in headers['content-disposition'].matches(/(\w+)="([^"]+)"/)}
                                        let name = disposition['name']

                                        if let $filename = disposition['filename'] {
                                            let f = {
                                                name: filename,
                                                type: headers['content-type'],
                                                content: Blob(content)
                                            }
                                            if let $fs = form[name] {
                                                fs.push(f)
                                            } else {
                                                form[name] = [f]
                                            }
                                        } else {
                                            form[disposition['name']] = content
                                        }
                                    }
                                    params.update(form)
                                },

                                (/^application\/x-www-form-urlencoded/, $body) => {
                                    params.update(decodeQuery(body))
                                }
                            }

                            if let $m = req.method and let (f, ps) = self.findHandler(m, url) {
                                try {
                                    rsp.status(f({*req, url, params, addr: c.addr}, rsp, **ps) ?? 200)
                                } catch e {
                                    rsp.header('Content-Type', 'text/plain')
                                    rsp.write("Exception: {e}")
                                    rsp.status(500)
                                }
                            } else {
                                rsp.status(404)
                            }

                            rsp.send(fd)
                        }
                    } else if ev & POLLHUP {
                        close(fd)
                        __conns.filter!(${it.fd != fd})
                    }
                }
            }
        }
    }
}
