import llhttp (..)
import os (..)
import json
import errno
import net
import log
import tp (ThreadPool)
import time

const READ_CHUNK_SIZE = (1 << 14) // 16 KiB

fn make-pattern(route: String) -> (Array[String], RegexV) {
    let route   = route.sub(/<(\w+)>/, [_, name] -> "<{name}:\\w+>")
    let params  = route.scan(/<(\w+):/).map(&1)
    let pattern = route.sub(/<\w+:(.*?)>/, [_, pattern] -> "({pattern})")
    (params, regex("^{pattern}/?$", 'v'))
}

class HttpResponse {
    statusCode: Int
    body:       Blob
    headers:    Dict[String, String]

    init() {
        statusCode = HTTP_STATUS_OK
        body = Blob()
        headers = %{'Content-Type': 'text/html'}
    }

    header(k, v) {
        if v == nil {
            headers[k]
        } else {
            headers[k] = "{v}"
        }
    }

    status(c) {
        statusCode = (c ?? statusCode)
    }

    write(s) {
        body.push(s)
    }

    json(x) {
        body.push(json::encode(x))
        header('Content-Type', 'application/json')
    }

    plain(x) {
        body.push("{x}")
        header('Content-Type', 'text/plain')
    }

    send(c) {
        let response = Blob([
            "HTTP/1.1 {statusCode} {statusName(statusCode)}",
            "Content-Length: {#body}",
            *["{k}: {v}" for k, v in headers],
            '',
            ''
        ].join('\r\n'))

        response.push(body)

        ::write(c, response, all=true)
    }
}

use RequestHandler = {req: HttpRequest, rsp: HttpResponse, params: *_} -> Int;

use RouteMap = Dict[
    String,
    Array[{
        route: String,
        params: Array[String],
        pattern: RegexV,
        fun: RequestHandler
    }]
];

class HttpServer {
    static __routes: RouteMap

    __sock:     Int
    __conns:    Array[HttpConnection]
    __free:     Array[HttpConnection]
    __stopping: Bool
    __handlers: RouteMap
    __threads:  Array[Thread[_]]
    __queue:    SharedQueue[(Int, HttpRequest)]
    __ev-r:     Int
    __ev-w:     Int

    init(*args, backlog: Int = 128) {
        __conns    = []
        __free     = []
        __stopping = false
        __handlers = %{*: []}
        __queue    = SharedQueue()
        (__ev-r, __ev-w) = pipe()

        for method, handlers in __routes {
            __handlers[method] = handlers.map(handler -> {
                *handler,
                fun: handler.fun.bind(self)
            })
        }

        match args {
            [addr: String, port: Int] => {
                __sock = net::listen('tcp', "{addr}:{port}", backlog)
            },

            [sock: Int] => {
                __sock = sock
                listen(__sock, backlog)
            }
        }

        __threads = [Thread(__thread) for ..ncpu()]
    }

    static __init_subclass__() {
        __routes = %{*: []}

        for _, method in self.__methods__ {
            if method.__class__ != self {
                continue
            }

            if not let $route = method.?__route {
                continue
            }

            __install(
                route.method,
                route.route,
                method
            )
        }
    }

    address -> (String, String) {
        getnameinfo(
            getsockname(__sock),
            NI_NUMERICHOST | NI_NUMERICSERV
        )
    }

    __resolve(
        method: String,
        url: String
    ) -> (RequestHandler, Dict[String, String]) | nil {
        if not let $handlers = __handlers[method] {
            return nil
        }

        for {params, pattern, fun, *} in handlers {
            if let $m = url.match(pattern) {
                return (fun, %{params[i]: m[i + 1]! for i in ..#params})
            }
        }
    }

    stop() { __stopping = true }

    static __install(method: String, route: String, f: RequestHandler) {
        let (params, pattern) = make-pattern(route)
        let handlers = __routes[method]
        handlers.push({
            route,
            params,
            pattern,
            fun: f
        })
        handlers.sort!(by=\-(_.route.search('<') ?? 99999))
    }

    static get(f, route) {
        f.__route = {method: 'GET', route}
        f
    }

    static post(f, route) {
        f.__route = {method: 'POST', route}
        f
    }

    static delete(f, route) {
        f.__route = {method: 'DELETE', route}
        f
    }

    static put(f, route) {
        f.__route = {method: 'PUT', route}
        f
    }

    __new-conn(sock: Int, addr: String, port: Int) -> HttpConnection {
        if let Some(conn) = __free.try-pop() {
            conn.reset(sock, addr, port)
        } else {
            HttpConnection(sock, addr, port)
        }
    }

    __go(fd: Int, req: HttpRequest) {
        let rsp = HttpResponse()

        if let (f, ps) = __resolve(req.method, req.url) {
            try {
                rsp.status(f(req, rsp, **ps) ?? 200)
            } catch e {
                rsp.plain("Exception: {e}\n\nBacktrace:\n{str(e.trace())}")
                rsp.status(500)
            }
        } else {
            rsp.status(404)
        }

        rsp.send(fd)
        req.end()

        write(__ev-w, 'x')
    }

    __thread() {
        catch _: CanceledError {
            return
        }

        while let (fd, req) = __queue.take() {
            __go(fd, req)
        }
    }

    run() {
        let polling = [__sock, __ev-r]
        let events  = []
        let buf     = Blob()

        while !__stopping {
            polling.take!(2)

            for __conns if !it.busy? {
                polling.push((it.fd, POLLIN, it))
            }

            if poll(polling, events, -1) <= 0 {
                log::warn!("poll(): {errno.str()}")
                continue
            }

            for match events {
                (self.__sock, POLLIN) => {
                    if let (conn, addr) = accept(__sock) {
                        let (addr, port) = getnameinfo(addr, NI_NUMERICHOST | NI_NUMERICSERV)
                        __conns.push(__new-conn(conn, addr, port))
                        log::debug!("New connection from {addr}:{port} on fd={conn} ({#__conns} active)")
                    } else {
                        log::warn!("accept(): {errno.str()}")
                    }
                },

                (self.__ev-r, POLLIN) => {
                    read(__ev-r, buf, READ_CHUNK_SIZE)
                    buf.clear()
                },

                (fd, ev, c) => {
                    if (ev & POLLIN) && read(fd, buf, READ_CHUNK_SIZE) > 0 {
                        match c.push(buf) {
                            Ok($req) => __queue.put((fd, req)),
                            Err(_)   => shutdown(fd, SHUT_RD),
                            _        => {}
                        }
                        buf.clear()
                    } else {
                        close(fd)
                        __conns.remove!(c)
                        __free.push(c)
                    }
                },

                (fd, ev, *) => {
                    log::warn!("Unexpected poll event {ev} on fd={fd}")
                }
            }
        }

        __queue.close()
        
        for __threads {
            it.join()
        }
    }
}
