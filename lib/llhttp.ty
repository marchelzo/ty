import ffi as c (C!)
import os

let HTTP_BOTH      = 0
let HTTP_REQUEST   = 1
let HTTP_RESPONSE  = 2

let F_CONNECTION_KEEP_ALIVE = 0x1
let F_CONNECTION_CLOSE = 0x2
let F_CONNECTION_UPGRADE = 0x4
let F_CHUNKED = 0x8
let F_UPGRADE = 0x10
let F_CONTENT_LENGTH = 0x20
let F_SKIPBODY = 0x40
let F_TRAILING = 0x80
let F_TRANSFER_ENCODING = 0x200

let HTTP_DELETE = 0
let HTTP_GET = 1
let HTTP_HEAD = 2
let HTTP_POST = 3
let HTTP_PUT = 4
let HTTP_CONNECT = 5
let HTTP_OPTIONS = 6
let HTTP_TRACE = 7
let HTTP_COPY = 8
let HTTP_LOCK = 9
let HTTP_MKCOL = 10
let HTTP_MOVE = 11
let HTTP_PROPFIND = 12
let HTTP_PROPPATCH = 13
let HTTP_SEARCH = 14
let HTTP_UNLOCK = 15
let HTTP_BIND = 16
let HTTP_REBIND = 17
let HTTP_UNBIND = 18
let HTTP_ACL = 19
let HTTP_REPORT = 20
let HTTP_MKACTIVITY = 21
let HTTP_CHECKOUT = 22
let HTTP_MERGE = 23
let HTTP_MSEARCH = 24
let HTTP_NOTIFY = 25
let HTTP_SUBSCRIBE = 26
let HTTP_UNSUBSCRIBE = 27
let HTTP_PATCH = 28
let HTTP_PURGE = 29
let HTTP_MKCALENDAR = 30
let HTTP_LINK = 31
let HTTP_UNLINK = 32
let HTTP_SOURCE = 33
let HTTP_PRI = 34
let HTTP_DESCRIBE = 35
let HTTP_ANNOUNCE = 36
let HTTP_SETUP = 37
let HTTP_PLAY = 38
let HTTP_PAUSE = 39
let HTTP_TEARDOWN = 40
let HTTP_GET_PARAMETER = 41
let HTTP_SET_PARAMETER = 42
let HTTP_REDIRECT = 43
let HTTP_RECORD = 44
let HTTP_FLUSH = 45

let HPE_OK = 0
let HPE_INTERNAL = 1
let HPE_STRICT = 2
let HPE_LF_EXPECTED = 3
let HPE_UNEXPECTED_CONTENT_LENGTH = 4
let HPE_CLOSED_CONNECTION = 5
let HPE_INVALID_METHOD = 6
let HPE_INVALID_URL = 7
let HPE_INVALID_CONSTANT = 8
let HPE_INVALID_VERSION = 9
let HPE_INVALID_HEADER_TOKEN = 10
let HPE_INVALID_CONTENT_LENGTH = 11
let HPE_INVALID_CHUNK_SIZE = 12
let HPE_INVALID_STATUS = 13
let HPE_INVALID_EOF_STATE = 14
let HPE_INVALID_TRANSFER_ENCODING = 15
let HPE_CB_MESSAGE_BEGIN = 16
let HPE_CB_HEADERS_COMPLETE = 17
let HPE_CB_MESSAGE_COMPLETE = 18
let HPE_CB_CHUNK_HEADER = 19
let HPE_CB_CHUNK_COMPLETE = 20
let HPE_PAUSED = 21
let HPE_PAUSED_UPGRADE = 22
let HPE_PAUSED_H2_UPGRADE = 23
let HPE_USER = 24

let HTTP_STATUS_CONTINUE = 100
let HTTP_STATUS_SWITCHING_PROTOCOLS = 101
let HTTP_STATUS_PROCESSING = 102
let HTTP_STATUS_EARLY_HINTS = 103
let HTTP_STATUS_RESPONSE_IS_STALE = 110
let HTTP_STATUS_REVALIDATION_FAILED = 111
let HTTP_STATUS_DISCONNECTED_OPERATION = 112
let HTTP_STATUS_HEURISTIC_EXPIRATION = 113
let HTTP_STATUS_MISCELLANEOUS_WARNING = 199
let HTTP_STATUS_OK = 200
let HTTP_STATUS_CREATED = 201
let HTTP_STATUS_ACCEPTED = 202
let HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION = 203
let HTTP_STATUS_NO_CONTENT = 204
let HTTP_STATUS_RESET_CONTENT = 205
let HTTP_STATUS_PARTIAL_CONTENT = 206
let HTTP_STATUS_MULTI_STATUS = 207
let HTTP_STATUS_ALREADY_REPORTED = 208
let HTTP_STATUS_TRANSFORMATION_APPLIED = 214
let HTTP_STATUS_IM_USED = 226
let HTTP_STATUS_MISCELLANEOUS_PERSISTENT_WARNING = 299
let HTTP_STATUS_MULTIPLE_CHOICES = 300
let HTTP_STATUS_MOVED_PERMANENTLY = 301
let HTTP_STATUS_FOUND = 302
let HTTP_STATUS_SEE_OTHER = 303
let HTTP_STATUS_NOT_MODIFIED = 304
let HTTP_STATUS_USE_PROXY = 305
let HTTP_STATUS_SWITCH_PROXY = 306
let HTTP_STATUS_TEMPORARY_REDIRECT = 307
let HTTP_STATUS_PERMANENT_REDIRECT = 308
let HTTP_STATUS_BAD_REQUEST = 400
let HTTP_STATUS_UNAUTHORIZED = 401
let HTTP_STATUS_PAYMENT_REQUIRED = 402
let HTTP_STATUS_FORBIDDEN = 403
let HTTP_STATUS_NOT_FOUND = 404
let HTTP_STATUS_METHOD_NOT_ALLOWED = 405
let HTTP_STATUS_NOT_ACCEPTABLE = 406
let HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED = 407
let HTTP_STATUS_REQUEST_TIMEOUT = 408
let HTTP_STATUS_CONFLICT = 409
let HTTP_STATUS_GONE = 410
let HTTP_STATUS_LENGTH_REQUIRED = 411
let HTTP_STATUS_PRECONDITION_FAILED = 412
let HTTP_STATUS_PAYLOAD_TOO_LARGE = 413
let HTTP_STATUS_URI_TOO_LONG = 414
let HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE = 415
let HTTP_STATUS_RANGE_NOT_SATISFIABLE = 416
let HTTP_STATUS_EXPECTATION_FAILED = 417
let HTTP_STATUS_IM_A_TEAPOT = 418
let HTTP_STATUS_PAGE_EXPIRED = 419
let HTTP_STATUS_ENHANCE_YOUR_CALM = 420
let HTTP_STATUS_MISDIRECTED_REQUEST = 421
let HTTP_STATUS_UNPROCESSABLE_ENTITY = 422
let HTTP_STATUS_LOCKED = 423
let HTTP_STATUS_FAILED_DEPENDENCY = 424
let HTTP_STATUS_TOO_EARLY = 425
let HTTP_STATUS_UPGRADE_REQUIRED = 426
let HTTP_STATUS_PRECONDITION_REQUIRED = 428
let HTTP_STATUS_TOO_MANY_REQUESTS = 429
let HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL = 430
let HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE = 431
let HTTP_STATUS_LOGIN_TIMEOUT = 440
let HTTP_STATUS_NO_RESPONSE = 444
let HTTP_STATUS_RETRY_WITH = 449
let HTTP_STATUS_BLOCKED_BY_PARENTAL_CONTROL = 450
let HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS = 451
let HTTP_STATUS_CLIENT_CLOSED_LOAD_BALANCED_REQUEST = 460
let HTTP_STATUS_INVALID_X_FORWARDED_FOR = 463
let HTTP_STATUS_REQUEST_HEADER_TOO_LARGE = 494
let HTTP_STATUS_SSL_CERTIFICATE_ERROR = 495
let HTTP_STATUS_SSL_CERTIFICATE_REQUIRED = 496
let HTTP_STATUS_HTTP_REQUEST_SENT_TO_HTTPS_PORT = 497
let HTTP_STATUS_INVALID_TOKEN = 498
let HTTP_STATUS_CLIENT_CLOSED_REQUEST = 499
let HTTP_STATUS_INTERNAL_SERVER_ERROR = 500
let HTTP_STATUS_NOT_IMPLEMENTED = 501
let HTTP_STATUS_BAD_GATEWAY = 502
let HTTP_STATUS_SERVICE_UNAVAILABLE = 503
let HTTP_STATUS_GATEWAY_TIMEOUT = 504
let HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED = 505
let HTTP_STATUS_VARIANT_ALSO_NEGOTIATES = 506
let HTTP_STATUS_INSUFFICIENT_STORAGE = 507
let HTTP_STATUS_LOOP_DETECTED = 508
let HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED = 509
let HTTP_STATUS_NOT_EXTENDED = 510
let HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED = 511
let HTTP_STATUS_WEB_SERVER_UNKNOWN_ERROR = 520
let HTTP_STATUS_WEB_SERVER_IS_DOWN = 521
let HTTP_STATUS_CONNECTION_TIMEOUT = 522
let HTTP_STATUS_ORIGIN_IS_UNREACHABLE = 523
let HTTP_STATUS_TIMEOUT_OCCURED = 524
let HTTP_STATUS_SSL_HANDSHAKE_FAILED = 525
let HTTP_STATUS_INVALID_SSL_CERTIFICATE = 526
let HTTP_STATUS_RAILGUN_ERROR = 527
let HTTP_STATUS_SITE_IS_OVERLOADED = 529
let HTTP_STATUS_SITE_IS_FROZEN = 530
let HTTP_STATUS_IDENTITY_PROVIDER_AUTHENTICATION_ERROR = 561
let HTTP_STATUS_NETWORK_READ_TIMEOUT = 598
let HTTP_STATUS_NETWORK_CONNECT_TIMEOUT = 599

if not let $llhttp = c.open('llhttp') {
    throw "failed to load llhttp shared library"
}

let llhttp_cb      = c.ptr
let llhttp_data_cb = c.ptr
let llhttp_type    = c.int

C! struct llhttp_internal {
  int32_t _index;
  void* _span_pos0;
  void* _span_cb0;
  int32_t error;
  const char* reason;
  const char* error_pos;
  void* data;
  void* _current;
  uint64_t content_length;
  uint8_t type;
  uint8_t method;
  uint8_t http_major;
  uint8_t http_minor;
  uint8_t header_state;
  uint16_t lenient_flags;
  uint8_t upgrade;
  uint8_t finish;
  uint16_t flags;
  uint16_t status_code;
  uint8_t initial_message_completed;
  void* settings;
};

C! struct llhttp_settings {
  /* Possible return values 0, -1, `HPE_PAUSED` */
  llhttp_cb      on_message_begin;

  /* Possible return values 0, -1, HPE_USER */
  llhttp_data_cb on_protocol;
  llhttp_data_cb on_url;
  llhttp_data_cb on_status;
  llhttp_data_cb on_method;
  llhttp_data_cb on_version;
  llhttp_data_cb on_header_field;
  llhttp_data_cb on_header_value;
  llhttp_data_cb on_chunk_extension_name;
  llhttp_data_cb on_chunk_extension_value;

  /* Possible return values:
   * 0  - Proceed normally
   * 1  - Assume that request/response has no body, and proceed to parsing the
   *      next message
   * 2  - Assume absence of body (as above) and make `llhttp_execute()` return
   *      `HPE_PAUSED_UPGRADE`
   * -1 - Error
   * `HPE_PAUSED`
   */
  llhttp_cb on_headers_complete;

  /* Possible return values 0, -1, HPE_USER */
  llhttp_data_cb on_body;

  /* Possible return values 0, -1, `HPE_PAUSED` */
  llhttp_cb on_message_complete;
  llhttp_cb on_protocol_complete;
  llhttp_cb on_url_complete;
  llhttp_cb on_status_complete;
  llhttp_cb on_method_complete;
  llhttp_cb on_version_complete;
  llhttp_cb on_header_field_complete;
  llhttp_cb on_header_value_complete;
  llhttp_cb on_chunk_extension_name_complete;
  llhttp_cb on_chunk_extension_value_complete;

  /* When on_chunk_header is called, the current chunk length is stored
   * in parser->content_length.
   * Possible return values 0, -1, `HPE_PAUSED`
   */
  llhttp_cb on_chunk_header;
  llhttp_cb on_chunk_complete;
  llhttp_cb on_reset;
};

C! llhttp fn {
    //llhttp_t *llhttp_alloc(llhttp_type type);
    //void llhttp_free(llhttp_t *parser);
    void llhttp_init(llhttp_t *parser, int type, struct llhttp_settings_t *settings);
    void llhttp_reset(llhttp_t *parser);
    void llhttp_settings_init(struct llhttp_settings_t *settings);
    int llhttp_execute(llhttp_t *parser, const char *data, c.u64 len);
    void llhttp_resume(llhttp_t *parser);
    const char *llhttp_method_name(int method);
    const char *llhttp_status_name(int status);
    const char *llhttp_errno_name(int err);
    const char *llhttp_get_error_reason(llhttp_t *parser);
    const char *llhttp_get_error_pos(llhttp_t *parser);
    uint8_t llhttp_get_method(llhttp_t *parser);
    int llhttp_get_status_code(llhttp_t *parser);
    uint8_t llhttp_get_http_major(llhttp_t *parser);
    uint8_t llhttp_get_http_minor(llhttp_t *parser);
}

let llhttp_get_version = parser -> {
    major: llhttp_get_http_major(parser),
    minor: llhttp_get_http_minor(parser)
}

let onMessageComplete = (parser) -> do {
    return 0
}

let onMessageBegin = (parser) -> do {
    return 0
}

let printData = (parser, data, len) -> do {
    return 0
}

let onHeaderField = (parser, data, len) -> do {
}

pub use HttpHeaders = Dict[String, String | [String]]
pub use HttpStatus  = {code: Int, text: String}
pub use HttpVersion = {major: Int, minor: Int}

pub use HttpMessage = {
    method:   ?String,
    version:  HttpVersion,
    ?url:     String,
    status:   ?HttpStatus,
    body:     ?Blob,
    headers:  HttpHeaders
}

class HttpParser {
    __ctx:      Ptr[_] | nil
    __mq:       Array[HttpMessage]
    __buf:      Blob
    __chunk:    Blob
    __closures: Array[_]
    __settings: _
    __headers:  HttpHeaders
    __url:      String | nil
    __header:   String | nil
    __status:   String | nil
    __err:      Int | nil

    init(type=HTTP_BOTH) {
        __mq = []
        __buf = Blob()

        __closures = []

        __reset()

        __settings = llhttp_settings()
        llhttp_settings_init(__settings)

        __ctx = llhttp_internal()
        llhttp_init(__ctx, type, __settings)

        __install('on_protocol',     c.int, c.ptr, c.ptr, c.u64, self.onData)
        __install('on_url',          c.int, c.ptr, c.ptr, c.u64, self.onData)
        __install('on_status',       c.int, c.ptr, c.ptr, c.u64, self.onData)
        __install('on_method',       c.int, c.ptr, c.ptr, c.u64, self.onData)
        __install('on_version',      c.int, c.ptr, c.ptr, c.u64, self.onData)
        __install('on_header_field', c.int, c.ptr, c.ptr, c.u64, self.onData)
        __install('on_header_value', c.int, c.ptr, c.ptr, c.u64, self.onData)
        __install('on_body',         c.int, c.ptr, c.ptr, c.u64, self.onData)

        __install('on_url_complete',          c.int, c.ptr, self.onURLComplete)
        __install('on_status_complete',       c.int, c.ptr, self.onStatusComplete)
        __install('on_method_complete',       c.int, c.ptr, self.onMethodComplete)
        __install('on_version_complete',      c.int, c.ptr, self.onVersionComplete)
        __install('on_header_field_complete', c.int, c.ptr, self.onHeaderFieldComplete)
        __install('on_header_value_complete', c.int, c.ptr, self.onHeaderValueComplete)
        __install('on_message_complete',      c.int, c.ptr, self.onMessageComplete)
    }

    __install(member, *args) {
        __closures.push(c.closure(*args))
        __settings.{member} = __closures[-1]
    }

    __reset() {
        __headers = %{}
        __url = nil
        __status = nil
    }

    onHeaderFieldComplete(parser) {
        __header = __buf.str()
        __buf.clear()
        HPE_OK
    }

    onHeaderValueComplete(parser) {
        let headerValue = __buf.str()
        __buf.clear()

        if let $field = __header {
            match __headers[field] {
                nil => __headers[field] = headerValue,

                vs: Array[String]
                    => vs.push(headerValue),

                v => __headers[field] = [v, headerValue]
            }
        }

        HPE_OK
    }

    onURLComplete(parser) {
        __url = __buf.str()
        __buf.clear()
        HPE_OK
    }

    onMethodComplete(parser) {
        __buf.clear()
        HPE_OK
    }

    onVersionComplete(parser) {
        __buf.clear()
        HPE_OK
    }

    onStatusComplete(parser) {
        __status = __buf.str()
        __buf.clear()
        HPE_OK
    }

    onData(parser, data, len) {
        __buf.push(c.as_str(data, len))
        return HPE_OK
    }

    onMessageComplete(parser) {
        let body = (#__buf > 0) ?: __buf
        if body {
            __buf = Blob()
        }

        let status = __status && {
            code: llhttp_get_status_code(parser),
            text: __status
        }

        let method = if status == nil {
            c.as_str(llhttp_method_name(llhttp_get_method(parser)))
        }

        __mq.push({
            method,
            url: cast(__url),
            status,
            version: llhttp_get_version(parser),
            headers: __headers,
            body: body if body != nil
        })

        __reset()

        return HPE_OK
    }

    push(chunk: String | Blob) {
        __chunk = (chunk :: String) ? Blob(chunk) : chunk
        __err   = llhttp_execute(__ctx, chunk, chunk.size())
    }

    takeMessages() -> Array[HttpMessage] {
        __mq.splice(0)
    }

    clearMessages() {
        __mq = []
    }

    messageCount() {
        __mq.len()
    }

    reset() {
        llhttp_reset(__ctx)
        __reset()
        __buf.clear()
        __mq.take!(0)
        __err = nil
    }

    destroy() {
        if __ctx != nil {
            c.free(__ctx)
            c.free(__settings)
            while __closures {
                c.freeClosure(__closures.pop())
            }
        }
        __ctx = nil
    }

    errorPos() {
        let pos = llhttp_get_error_pos(__ctx)
        (pos - __chunk.ptr())
    }

    error() {
        c.as_str(llhttp_errno_name(__err))
    }
}

pub fn statusName(code: Int) -> String {
    c.as_str(llhttp_status_name(code))
}
