pub class Heap[K, T] {
    __key: Array[K]
    __xs:  Array[T]
    __n:   Int

    init(items: Iterable[(K, T)] = []) {
        __key = []
        __xs  = []
        __n   = 0

        for (k, x) in items {
            __key.push(k)
            __xs.push(x)
        }

        __heapify()
    }

    swap(i: Int, j: Int) {
        __key[i], __key[j] = __key[j], __key[i]
        __xs[i],  __xs[j]  = __xs[j],  __xs[i]
    }

    push(key: K, val: T) {
        __key.push(key)
        __xs.push(val)

        let i = __xs.len() - 1
        let p = (i - 1) / 2

        while p >= 0 && __key[i] < __key[p] {
            __swap(i, p)
            i = p
            p = (p - 1) / 2
        }
    }

    pop() -> (K, T) {
        if __xs.len() == 0 {
            throw ValueError('pop from empty heap')
        }

        let x = __xs[0]
        let k = __key[0]

        __key[0] = __key[-1]
        __xs[0]  = __xs[-1]

        __key.pop()
        __xs.pop()

        let i = 0
        let l = 1
        let r = 2

        while l < #__xs {
            let c = i
            if __key[l] < __key[c] {
                c = l
            }
            if r < #__xs && __key[r] < __key[c] {
                c = r
            }
            if c == i {
                break
            }
            __swap(i, c)
            i = c
            l = 2 * i + 1
            r = l + 1
        }

        return (k, x)
    }

    #() -> Int {
        #__xs
    }

    __iter__*() {
        for k, i in __key {
            yield (k, __xs[i])
        }
    }


}
