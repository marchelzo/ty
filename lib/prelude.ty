import bit
import math
import thread
import base64
import time
import ffi as c
import ty
import ty.parse as parse
import ty.token as lex
import os

tag MatchError;
tag IndexError;
tag DispatchError;

tag None {
     map()     { None }
     flatMap() { None }
     some?()   { false }
}

tag Some {
    map(f) {
        Some(f(self))
    }

    flatMap(f) {
        f(self)
    }

    static from(x) {
        match x {
            nil => None,
            _   => Some(x)
        }
    }

    some?() { true }
}

tag Ok {
     map(f) {
          Ok(f(self))
     }

     flatMap(f) {
          f(self)
     }
}

tag Err {
     map()     { self }
     flatMap() { self }
}

class Object {
    init(%props) {
        for k, v in props {
            member(self, k, v)
        }
    }

    is?(c) {
        subclass?(type(self), c)
    }

    drill(path) {
        let x = self

        for i in path {
            x = x[i]
        }

        return x
    }

    members() {
        members(self)
    }

    member(*args) {
        member(self, *args)
    }

    |(other) {
        c -> (c :: self) || (c :: other)
    }

    &(other) {
        c -> (c :: self) && (c :: other)
    }

    !::(x) {
        !(self :: x)
    }

    :>(other) {
        x -> (self(x) :: other)
    }

    <.>(other) {
        (*xs) -> self(other(*xs))
    }

    |>(f) {
        f@(self(*, **))
    }

    *>(f) {
        f(self)
    }

    __match__(other) {
        self == other
    }

    __question__() {
        (x -> x == nil) | self
    }

    __str__() {
        str(self)
    }

    __fmt__(fmt) {
        str(self)
    }
}

class Class {
    |(other) {
        c -> (c :: self) || (c :: other)
    }

    &(other) {
        c -> (c :: self) && (c :: other)
    }

    __match__(other) {
        type(other) != Class && other.is?(self)
    }
}

class Function : Iter {
    init() {
        id
    }

    flip() {
        (a, b) -> self(b, a)
    }

    bind(x) {
        bindMethod(self, x)
    }

    apply(x, *ys) {
        apply(self, x, *ys)
    }

    __match__(x) {
        self(x)
    }

    __next__() {
        Some(self())
    }

    &&&(g) {
        x -> (self(x), g(x))
    }

    ***(g) {
        |(x, y)| -> (self(x), g(y))
    }

    >>(g) {
        \do {
            self(*, **)
            g(*, **)
        }
    }
}

class Array : Iterable {
    init(*xs) {
        xs
    }

    of(*shape, fill) {
        match shape {
            [k]      => [fill for _ in ..k],
            [k, *ks] => [Array.of(*ks, fill: fill) for _ in ..k]
        }
    }

    shape() {
        let s = []
        let x = self
        while x :: Array {
            s.push(#x)
            x = x[0]
        }
        return s
    }

    map?(f) {
        let ys = []

        for x in self {
            if let Some(y) = f(x) {
                ys.push(y)
            }
        }

        return ys
    }

    T() {
        let t = [[nil for _ in self] for _ in self[0]]

        for i in ..#self {
            for j in ..#self[i] {
                t[j][i] = self[i][j]
            }
        }

        return t
    }

    indices*() {
        for x, i in self {
            if x :: Array {
                for idx in x.indices() {
                    yield (idx :: Array) ? ([i] + idx) : [i, idx]
                }
            } else {
                yield i
            }
        }
    }

    flatMap(f) {
        self.map(f).flat(1)
    }

    sorted?() {
        for i in 1..#self {
            if self[i - 1] > self[i] {
                return false
            }
        }

        return true
    }

    at(i) {
        if i < #self {
            self[i]
        }
    }

    empty?() {
        #self == 0
    }

    cycle*() {
        if #self == 0 {
            return None
        }

        while true {
            for x in self {
                yield x
            }
        }
    }

    str() {
        @map(str).sum()
    }

    list() {
        self
    }

    mean(f = id) {
        match self {
            [] => nil,
            _  => @map(f |> float).sum() / @len()
        }
    }

    median() {
        match self {
            []                 => nil,
            xs :: xs.sorted?() => xs[#xs / 2],
            xs                 => @sort()[#self / 2]
        }
    }

    coalesce() {
        for x in self if x != nil {
            return x
        }
    }

    argmax(f = id) {
        if #self == 0 { return nil }

        let i, max = 0, f(self[0])

        for j in 1..#self {
            let y = f(self[j])
            if y > max {
                i, max = j, y
            }
        }

        return i
    }

    popWhile(p) {
        while #self > 0 && p(self[-1]) {
            self.pop()
        }

        return self
    }

    __iter__*() {
        for x in self { yield x }
    }

    __subscript__(T) {
        if self == Array {
            return xs -> (xs :: Array) && xs.all?(x -> x :: T)
        } else {
            return self[T]
        }
    }

    __slice__(i=0, j, k=1) {
        let slice = []

        let wrap = match {
            $ix :: ix < 0 => ix + #self,
            ix            => ix
        }

        if k < 0 {
            let start = min(wrap(i - 1), #self)
            let stop = max(wrap(j ?? 0), 0)
            for let ix = start; ix >= stop; ix += k {
                if let Some(x) = self.get(ix) {
                    slice.push(x)
                }
            }
        } else {
            let start = max(wrap(i), 0)
            let stop = min(wrap(j ?? #self), #self)
            for let ix = start; ix < stop; ix += k {
                if let Some(x) = self.get(ix) {
                    slice.push(x)
                }
            }
        }

        return slice
    }

    get(i) {
        let n = #self
        (i in -n..n) ? Some(self[i]) : None
    }
}

class Dict : Iterable {
    init(ks, vs) {
        if ks && vs {
            return %{ k: v for (k, v) in ks.zip(vs) }
        } else {
            return %{}
        }
    }

    map(f) {
        return %{ k: f(v) for k, v in self }
    }

    kmap(f, combine) {
        let new = %{}
        for k, v in self {
            let key = f(k)
            if new.has?(key) {
                new[key] = combine(new[key], v)
            } else {
                new[key] = v
            }
        }
        return new
    }

    <<(x) {
        self[x] ?= nil
    }

    iterValues*() {
        for _, v in self {
            yield v
        }
    }

    __iter__() {
        return @keys().zip(@values()).__iter__()
    }
}

class String : Iterable {
    init(x) {
        return str(x)
    }

    int(base: Int = 10) {
        return int(self, base)
    }

    center(n, c = ' ') {
        let d = max(0, n - #self)
        self.padLeft(n - d/2, c).padRight(n, c)
    }

    reverse() {
        return @chars().reverse!().sum() ?? ''
    }

    num?() {
        return @match?(/^\d+(?:\.\d+)?$/)
    }

    ends?(s) {
        s == '' || s == self.slice(-#s)
    }

    starts?(s) {
        s == self.slice(0, #s)
    }

    splice(i, j) {
        self.slice(i, j - i)
    }

    bsplice(i, j) {
        self.bslice(i, j - i)
    }

    lower?() {
        return self == @lower()
    }

    upper?() {
        return self == @upper()
    }

    searchr(pattern) {
        for let off = @len() - 1; off >= 0; --off {
            if let $i = @search(pattern, off) {
                return i
            }
        }
    }

    trim() {
        return @comb(/^\s+|\s+$/)
    }

    trimRight() {
        @comb(/\s+$/)
    }

    trimLeft() {
        @comb(/^\s+/)
    }

    strip() {
        return @comb(/^\s+|\s+$/)
    }

    stripRight() {
        @comb(/\s+$/)
    }

    stripLeft() {
        @comb(/^\s+/)
    }

    unhex() {
        let b = Blob()

        for octet in self.matches(/../) {
            if let $x = int(octet, 16) {
                b.push(x)
            } else {
                return nil
            }
        }

        return b
    }

    editDistance(other) {
        let a, b = self, other

        let D = [[0 for _ in ...#b] for _ in ...#a]

        for i in ...#a {
            D[i][0] = i
        }

        for j in ...#b {
            D[0][j] = j
        }

        for i in ..#a {
            for j in ..#b {
                let cost = (a[i] == b[j]) ? 0 : 1

                D[i + 1][j + 1] = min(
                    D[i][j + 1] + 1,
                    D[i + 1][j] + 1,
                    D[i][j] + cost
                )

                if i > 0 && j > 0 && a[i] == b[j - 1] && b[j] == a[i - 1] {
                    D[i + 1][j + 1] = min(D[i + 1][j + 1], D[i - 1][j - 1] + 1)
                }
            }
        }

        D[#a][#b]
    }

    __count__() {
        (ord(self)..).map(chr)
    }

    -(end) {
        self.slice(0, -#end if end == self.slice(-#end))
    }

    __iter__*() {
        for c in @chars() {
            yield c
        }
    }

    __fmt__(spec, w) {
        if spec.match?(/[A-z]/) {
            fmt("%{spec}", w if '*' in spec, self)
        } else {
            fmt("%{spec}s", w if '*' in spec, self)
        }
    }
}

class Int {
    init(x)  {
        int(x ?? 0)
    }

    ^(b)    { bit.XOR(self, b)        }
    .&.(b)  { bit.AND(self, b)        }
    .|.(b)  { bit.OR(self, b)         }
    <<(b)   { bit.shiftLeft(self, b)  }
    >>(b)   { bit.shiftRight(self, b) }

    **(x) {
        type(x)(math.pow(self, x))
    }

    upto*(b: Int) {
        while self <= b {
            yield self++
        }
    }

    even?() {
        self % 2 == 0
    }

    odd?() {
        self % 2 == 1
    }

    sgn() {
        self <=> 0
    }

    str(base: Int = 10) {
        let digits = '0123456789ABCDEF'

        if base == 10 { return str(self) }

        let s = ''
        let k = abs(self)

        while k != 0 || #s == 0 {
            s = digits[k % base] + s
            k /= base
        }

        (self < 0) ? ('-' + s) : s
    }

    downto*(b: Int) {
        while self >= b {
            yield self--
        }
    }

    count*(k: Int = 1) {
        while true {
            yield self
            self += k
        }
    }

    __count__*() {
        while true { yield self++ }
    }

    __iter__*() {
        while true { yield self++ }
    }

    negate() {
        -self
    }

    sub(n) {
        self - n
    }

    add(n) {
        self + n
    }

    mul(n) {
        self * n
    }

    div(n) {
        self / int(n)
    }

    mod(n) {
        self % int(n)
    }

    in?(r: Range) {
        self in r
    }

    pred() {
        self - 1
    }

    succ() {
        self + 1
    }

    zero?() {
        self == 0
    }

    nonZero?() {
        self != 0
    }

    positive?() {
        self > 0
    }

    negative?() {
        self < 0
    }

    clamp(*args) {
        Float.clamp.bind(self)(*args)
    }

    __fmt__(spec, w) {
        if spec.match?(/[a-z]/) {
            fmt("%{spec}", w if '*' in spec, self)
        } else {
            fmt("%{spec}d", w if '*' in spec, self)
        }
    }
}

class Float {
    init(x) {
        float(x)
    }

    **(b: Int | Float) {
        return math.pow(self, b)
    }

    negate() {
        -self
    }

    sub(n) {
        self - n
    }

    add(n) {
        self + n
    }

    mul(n) {
        self * n
    }

    nan?() {
        math.nan?(self)
    }

    clamp(*args) {
        match args {
            [low, high] => {
                return if self < low {
                    low
                } else if self > high {
                    high
                } else {
                    self
                }
            },

            [range] => {
                @clamp(range.low(), range.high())
            }
        }
    }

    __fmt__(spec, w) {
        if spec.match?(/[A-z]/) {
            fmt("%{spec}", w if '*' in spec, self)
        } else {
            fmt("%{spec}f", w if '*' in spec, self)
        }
    }

    str(prec: ?Int) {
        if prec == nil {
            str(self)
        } else {
            let p10 = math.pow(10, prec)
            let [whole, ?frac] = str(iround(self * p10) / p10).split('.')
            return "{whole}.{(frac ?? '').padRight(prec, '0')}"
        }
    }
}

class Blob : Iterable {
    init(*args) {
        let b = blob()

        for arg in args {
            if (arg :: Iterable) && !(arg :: String) {
                for c in arg {
                    b.push(c)
                }
            } else {
                b.push(arg)
            }
        }

        return b
    }

    searchr(s) {
        for let off = @size() - 1; off >= 0; --off {
            if let $i = @search(off, s) {
                return i
            }
        }
    }

    base64() {
        base64.encode(self)
    }

    __iter__*() {
        for x in self {
            yield x
        }
    }
}

class Bool {
    init(x) {
        return bool(x)
    }

    __not__() { return !self }
}

class Regex {
    init(x) { regex(x) }

    ~=(s) { s.match!(self) }

    test(s) { s.match?(self) }

    exec(s) { s.match!(self) }

    __match__(s) {
        (s :: String) && s.match?(self)
    }
}

class Generator : Iter {
    init*(f) {
        while let Some(x) = f() {
            yield x
        }
    }

    __next__() {
        self()
    }
}

class Tag {
}

class Tuple {
    init(*args, %kwargs) {
        tuple(*args, **kwargs)
    }

    __str___() {
        str(self)
    }

    %(t) {
        let myMembers = members(self)
        let tMembers = members(t)

        for k, v in tMembers {
            if let $c = myMembers[k] {
                myMembers[k] = (c.?isTuple() && v.?isTuple()) ? (c % v) : v(c)
            } else {
                myMembers[k] = v(nil)
            }
        }

        tuple(**myMembers)
    }

    isTuple() {
        true
    }

    __drop__() {
        try {
            for i in 0.count() {
                self[i].?__drop__()
            }
        } catch _ :: IndexError;
    }

    __match__(t) {
        let myMembers = members(self)
        let tMembers = members(t)

        if #myMembers.diff(tMembers) != 0 {
            return false
        }

        for k, v in tMembers {
            if !(v :: myMembers[k]) {
                return false
            }
        }

        return true
    }
}

class RegexMatch {
    init(s, groups) {
        let [(start, size), *captures] = groups
        @s_ = s
        @s = s.bslice(start, size)
        @start = #s.bslice(0, start)
        @size = #@s
        @captures = captures
    }

    pre {
        @s_.bslice(0, @start)
    }

    post {
        @s_.bslice(@start + @size)
    }

    __subscript__(i) {
        if i == 0 {
            @s
        } else {
            let (off, n) = @captures[i - 1]
            @s_.bslice(off, n)
        }
    }

    __len__() {
        @size
    }
}

class Iterable {
    map(f) {
        @__iter__().map(f)
    }

    filter(f) {
        @__iter__().filter(f)
    }

    reverse() {
        @__iter__().reverse()
    }

    list() {
        @__iter__().list()
    }

    uniq(f) {
        @__iter__().uniq(f)
    }

    take(n) {
        @__iter__().take(n)
    }

    takeWhile(pred) {
        @__iter__().takeWhile(pred)
    }

    drop(n) {
        @__iter__().drop(n)
    }

    dropWhile(pred) {
        @__iter__().dropWhile(pred)
    }

    set() {
        @__iter__().set()
    }

    str() {
        @__iter__().str()
    }

    join(s) {
        @__iter__().join(s)
    }

    unlines() {
        @__iter__().unlines()
    }

    unwords() {
        @__iter__().unwords()
    }

    tally(f) {
        @__iter__().tally(f)
    }

    each(f) {
        @__iter__().each(f)
    }

    min(k) {
        @__iter__().min(k)
    }

    max(k) {
        @__iter__().max(k)
    }

    minmax(k) {
        @__iter__().minmax(k)
    }

    count(x) {
        @__iter__().count(x)
    }

    intersperse(x) {
        @__iter__().intersperse(x)
    }

    groupsOf(n, keepShort) {
        @__iter__().groupsOf(n, keepShort)
    }

    classify(f = id) {
        @__iter__().classify(f)
    }

    pad(n, x) {
        @__iter__().pad(n, x)
    }

    zip(*its, longest) {
        @__iter__().zip(*its, longest: longest)
    }

    zipWith(f, *its, longest) {
        @__iter__().zipWith(f, *its, longest: longest)
    }

    unzip() {
        @__iter__().unzip()
    }

    unzipWith(f) {
        @__iter__().unzipWith(f)
    }

    mean() {
        @__iter__().mean()
    }

    median() {
        @__iter__().median()
    }

    sum() {
        @__iter__().sum()
    }

    fold(a, b) {
        @__iter__().fold(a, b)
    }

    group(f) {
        @__iter__().group(f)
    }

    chain(A, B) {
        A.__iter__().chain(B)
    }

    cycle() {
        @list().cycle()
    }

    repeat(n) {
        @__iter__().repeat(n)
    }

    all?(pred=id) {
        @__iter__().all?(pred)
    }

    interleave(xs) {
        @__iter__().interleave(xs)
    }

    enumerate() {
        @__iter__().enumerate()
    }

    find(p) {
        @__iter__().find(p)
    }

    __len__() {
        @__iter__().__len__()
    }

    __subscript__(i) {
        @__iter__().__subscript__(i)
    }

    __iter__() -> Iter;
}

class Iter : Iterable {
    map*(f) {
        for x in self {
            yield f(x)
        }
    }

    map?*(f) {
        for x in self {
            if let Some(y) = f(x) {
                yield y
            }
        }
    }

    filter*(f) {
        for x in self if f(x) {
            yield x
        }
    }

    fold(x, f) {
        if f == nil {
            f = x
            if not Some(x) = @__next__() {
                return nil
            }
        }

        while let Some(y) = @__next__() {
            x = f(x, y)
        }

        return x
    }

    __len__() {
        let n = 0

        for _ in self {
            n += 1
        }

        return n
    }

    uniq*(f: Function = id) {
        let seen = %{}
        for x in self {
            let y = f(x)
            if y not in seen {
                seen << y
                yield x
            }
        }
    }

    unzipWith(f) {
        let lists = []

        for x in self {
            let t = f(x)
            let n = #members(t)

            while #lists < n {
                lists.push([])
            }

            for i in ..n {
                lists[i].push(t[i])
            }
        }

        return tuple(*lists)
    }

    unzip() {
        @unzipWith(id)
    }

    zipWith*(f, *its, longest) {
        its.map!(&__iter__)
        its.insert(0, self)

        while true {
            let group = []

            for it in its {
                group.push(it.__next__())
            }

            if group.all?(Some) || (group.any?(Some) && longest) {
                yield f(*group.map!(x -> match x {
                    None    => nil,
                    Some(x) => x
                }))
            } else {
                break
            }
        }
    }

    zip(*its, longest = false) {
        @zipWith(tuple, *its, longest: longest)
    }

    pad*(n, x) {
        let i = 0
        for x in self {
            yield x
            i += 1
        }
        while i < n {
            yield x
            i += 1
        }
    }

    find(p) {
        for x in self {
            if p(x) return x
        }
    }

    group(f = id) {
        if not let Some(x) = @__next__() {
            return [].__iter__()
        }

        let g = [x]

        return Generator(function () {
            while let Some(x) = @__next__() {
                if f(x) == f(g[-1]) {
                    g.push(x)
                } else {
                    let group = g
                    g = [x]
                    return Some(group)
                }
            }

            if g {
                let g_ = g
                g = nil
                return Some(g_)
            } else {
                None
            }
        })
    }

    classify(f = id) {
        let d = %{*: []}

        for x in self {
            d[f(x)].push(x)
        }

        return d
    }

    groupsOf*(n: Int & n >= 0, keepShort: Bool = true) {
        while let xs = @take(n).list() and #xs > 0 {
            if #xs == n || keepShort {
                yield xs
            }
        }
    }

    join(sep: String) {
        if not let Some(str ~> $s) = @__next__() {
            return ''
        }

        let b = blob()
        b.push(s)

        while let Some(s) = @__next__() {
            b.push(sep)
            b.push(str(s))
        }

        return b.str()
    }

    unlines() {
        return @join("\n")
    }

    unwords() {
        return @join(' ')
    }

    count(x) {
        let n = 0

        if x :: (Function | Regex) {
            for y in self {
                if x(y) { n += 1 }
            }
        } else for y in self {
            if x == y { n += 1 }
        }

        return n
    }

    interleave*(ys, long=true) {
        ys = ys.__iter__()
        for x in self {
            yield x
            if let Some(y) = ys.__next__() {
                yield y
            }
        }
        if long {
            for y in ys {
                yield y
            }
        }
    }

    list() {
        [x for x in self]
    }

    reverse() {
        return ReverseIter(self)
    }

    take*(n) {
        for _ in ..n {
            if let Some(x) = @__next__() {
                yield x
            } else {
                break
            }
        }
    }

    takeWhile*(pred) {
        while let Some(x) = @__next__() {
            if pred(x) {
                yield x
            } else {
                break
            }
        }
    }

    drop(n) {
        for _ in ..n { @__next__() }
        return self
    }

    dropWhile*(pred) {
        while let Some(x) = @__next__() {
            if !pred(x) {
                yield x
                break
            }
        }
        while let Some(x) = @__next__() {
            yield x
        }
    }

    set() {
        return %{ x for x in self }
    }

    str() {
        let b = blob()

        for s in self {
            b.push(str(s))
        }

        return b.str()
    }

    tally(f = id) {
        let d = %{*:0}
        for x in self { d[f(x)] += 1 }
        return d
    }

    each(f) {
        for x in self { f(x) }
    }

    enumerate*() {
        let i = 0
        for x in self {
            yield (i++, x)
        }
    }

    max(k = id) {
        if not let Some(x) = @__next__() {
            return nil
        }

        let m = x
        let mKey = k(m)

        while let Some(x) = @__next__() {
            let key = k(x)
            if key > mKey {
                m, mKey = x, key
            }
        }

        return m
    }

    min(k = id) {
        if not let Some(x) = @__next__() {
            return nil
        }

        let m = x
        let mKey = k(m)

        while let Some(x) = @__next__() {
            let key = k(x)
            if key < mKey {
                m, mKey = x, key
            }
        }

        return m
    }

    minmax(k = id) {
        if not let Some(x) = @__next__() {
            return nil
        }

        let max = x
        let maxKey = k(x)

        let min = max
        let minKey = maxKey

        while let Some(x) = @__next__() {
            let key = k(x)
            if key < minKey {
                min, minKey = x, key
            } else if key > maxKey {
                max, maxKey = x, key
            }
        }

        return (min, max)
    }

    intersperse*(sep) {
        let first = true;
        for x in self {
            if !first {
                yield sep
            }

            yield x

            first = false
        }
    }

    chainAll*() {
        for it in self {
            for x in it.__iter__() {
                yield x
            }
        }
    }

    static chain*(*its) {
        for it in its {
            for x in it.__iter__() {
                yield x
            }
        }
    }

    cycle() {
        return @list().cycle()
    }

    repeat*(n) {
        let xs = []

        for x in self {
            yield x
            xs.push(x)
        }

        let i = 1

        while i != n {
            for x in xs { yield x }
            i += 1
        }
    }

    replicate*(x, n) {
        for _ in ..n {
            yield x
        }
    }

    sum() {
        return @list().sum()
    }

    mean() {
        return @list().mean()
    }

    median() {
        return @list().median()
    }

    all?(pred=id) {
        for x in self {
            if !pred(x) { return false }
        }

        return true
    }

    static tee(it, n = 2) {
        let queues = [Queue() for _ in ..n]
        let it = it.__iter__()

        function get() {
            if let Some(x) = it.__next__() {
                for queue in queues {
                    queue.put(x)
                }
                return true
            } else {
                return false
            }
        }

        let generators = queues.map(queue -> generator {
            while true {
                if let Some(x) = queue.tryTake() {
                    yield x
                } else if !get() {
                    return None
                }
            }
        })

        return tuple(*generators)
    }

    dict() {
        %{ k: v for (k, v) in self }
    }

    __subscript__(i) {
        for _ in ..(i - 1) {
            if @__next__() == None { return nil }
        }

        if let Some(x) = @__next__() {
            return x
        }
    }

    __iter__() { self }
}

class ReverseIter : Iter {
    init(I) {
        @xs = []
        while let Some(x) = I.__next__() {
            @xs.push(x)
        }
    }

    __next__() {
        if @xs {
            Some(@xs.pop())
        } else {
            None
        }
    }
}

class Queue : Iterable {
    init(xs=[]) {
        @xs = []
        @i = 0
        @j = 0

        for x in xs {
            self.put(x)
        }
    }

    __len__() {
        if @xs {
            (@j - @i + #@xs) % #@xs
        } else {
            0
        }
    }

    empty?() {
        #self == 0
    }

    put(x) {
        if !@xs {
            @xs = [x, nil]
            @j = 1
        } else if (@j + 1) % #@xs == @i {
            let n = #self
            @xs.rotate!(@i)
            @xs += @xs
            @i = 0
            @j = n + 1
            @xs[n] = x
        } else {
            @xs[@j] = x
            @j = (@j + 1) % #@xs
        }
    }

    tryTake() {
        if #self == 0 {
            return None
        }

        let x = @xs[@i]
        @i = (@i + 1) % #@xs

        return Some(x)
    }

    take() {
        let Some(x) = self.tryTake()
        return x
    }

    __iter__*() {
        for let i = @i; i != @j; i = (i + 1) % #@xs {
            yield @xs[i]
        }
    }
}

class Range : Iterable {
    init(a, b) {
        @a = a
        @b = b
    }

    low() {
        return min(@a, @b)
    }

    high() {
        return max(@a, @b) - 1
    }

    __len__() {
        return @high() - @low() + 1
    }

    __str__() {
        return "({@a} .. {@b})"
    }

    contains?(k) {
        k :: self
    }

    __match__(x) {
        (x :: (Int | Float)) && (x >= @low() && x <= @high())
    }

    has?(k) {
        k :: self
    }

    __iter__() {
        let a, b = @a, @b
        return if a < b {
            a.upto(b - 1)
        } else {
            (a - 1).downto(b)
        }
    }
}

class InclusiveRange : Range {
    __str__() {
        return "({@a} ... {@b})"
    }

    __iter__() {
        let a, b = @a, @b

        if a < b {
            a.upto(b)
        } else {
            a.downto(b)
        }
    }

    high() {
        max(@a, @b)
    }
}

function id(x) { x }

function len(xs) {
    #xs
}

function zip(*xs) {
    match xs {
        [x, *xs] => x.zip(*xs),
        []       => []
    }
}

function onExit(f) {
    __EXIT_HOOKS__.push(f)
}

function printf(*args, %kwargs) {
    print(fmt(*args), **kwargs)
}

function uuid4() {
    let b = Blob(*[rand(256) for _ in ..16])

    b.set(6, 0x40 .|. (b[6] .&. 0x0F))
    b.set(8, 0xA0 .|. (b[8] .&. 0x3F))

    let hex = b.hex()

    return [
        hex.slice(0, 8),
        hex.slice(8, 4),
        hex.slice(12, 4),
        hex.slice(16, 4),
        hex.slice(20, 12)
    ].join('-')
}

function uuid7(pseudo = true) {
    let b = if pseudo {
        Blob(*[rand(256) for _ in ..16])
    } else {
        let fd = os.open('/dev/urandom', os.O_RDONLY)
        defer os.close(fd)
        os.read(fd, 16)
    }

    b.set(6, 0x70 .|. (b[6] .&. 0x0F))
    b.set(8, 0x80 .|. (b[8] .&. 0x3F))

    let t = time.utime() / 1000

    b[0] = t >> 40
    b[1] = t >> 32
    b[2] = t >> 24
    b[3] = t >> 16
    b[4] = t >>  8
    b[5] = t >>  0

    let hex = b.hex()

    return [
        hex.slice(0, 8),
        hex.slice(8, 4),
        hex.slice(12, 4),
        hex.slice(16, 4),
        hex.slice(20, 12)
    ].join('-')
}

class Mutex {
    init() {
        @mtx = thread.mutex()
        @waited = 0
    }

    inner() {
        @mtx
    }

    lock() {
        let start = time.utime()
        thread.lock(@mtx)
        @waited += time.utime() - start
        return MutexLock(@mtx)
    }

    tryLock() {
        if thread.tryLock(@mtx) == 0 {
            return MutexLock(@mtx)
        }
    }

    unlock() {
        thread.unlock(@mtx)
    }

    destroy() {
        thread.destroyMutex(@mtx)
    }

    __free__() {
        @destroy()
    }
}

class MutexLock {
    init(mtx) {
        @mtx = mtx
    }

    __drop__() {
        thread.unlock(@mtx)
    }
}

class Channel {
    init() {
        @chan = thread.channel()
    }

    send(x) {
        thread.send(@chan, x)
    }

    recv(timeoutMs: ?Int) {
        thread.recv(@chan, timeoutMs if timeoutMs != nil)
    }
}

class Sync {
    init(x, mutex = Mutex()) {
        @x = x
        @mtx = mutex
    }

    static swap(x, y) {
        with x.mtx.lock() {
            let old = x.x
            x.x = y
            old
        }
    }

    static read(x) {
        with x.mtx.lock() {
            x.x
        }
    }

    static get(x) {
        x.x
    }

    static set(x, y) {
        with x.mtx.lock() {
            x.x = y
        }
    }

    static lock(x) {
        x.mtx.lock()
    }

    __missing__(name, *args) {
        with @mtx.lock() {
            let f = member(@x, name)
            f(*args)
        }
    }

    ==(y) {
        with @mtx.lock() {
            @x == y
        }
    }

    <=>(y) {
        with @mtx.lock() {
            @x <=> y
        }
    }

    __len__() {
        with @mtx.lock() {
            #@x
        }
    }

    __str__() {
        "{@x}"
    }

    __subscript__(i) {
        with @mtx.lock() {
            @x[i]
        }
    }

    ++() {
        with @mtx.lock() {
            ++(@x)
        }
    }


    --() {
        with @mtx.lock() {
            --(@x)
        }
    }

    +=(y) {
        with @mtx.lock() {
            @x += y
        }
    }

    +(y) {
        with @mtx.lock() {
            @x + y
        }
    }

    *=(y) {
        with @mtx.lock() {
            @x *= y
        }
    }

    *(y) {
        with @mtx.lock() {
            @x * y
        }
    }

    -=(y) {
        with @mtx.lock() {
            @x -= y
        }
    }

    -(y) {
        with @mtx.lock() {
            @x - y
        }
    }

    /=(y) {
        with @mtx.lock() {
            @x /= y
        }
    }

    /(y) {
        with @mtx.lock() {
            @x / y
        }
    }
}

class CondVar {
    init() {
        @var = thread.cond()
    }

    destroy() {
        thread.destroyCond(@var)
    }

    wait(mtx, *timeout) {
        thread.waitCond(@var, mtx.inner(), *timeout)
    }

    signal() {
        thread.signalCond(@var)
    }

    broadcast() {
        thread.broadcastCond(@var)
    }

    __free__() {
        @destroy()
    }
}

class Thread {
    /*
     * Thread(func, *args, isolated=false, name=nil)
     *
     * Call the specified function with any provided arguments in a
     * new thread.
     *
     * isolated: If isolated is true, the new thread will be in its own thread
     *           group, and will not synchronize its garbage collection with
     *           other threads. This can be useful if the thread is generating
     *           little to no garbage and needs to avoid garbage collection
     *           pauses.
     *
     *           NOTE A side effect of this is that references held by the new thread
     *                to objects allocated in other thread groups will not keep those
     *                objects alive. You must take care to avoid use-after-free bugs,
     *                and use Channel to transfer objects between thread groups.
     */
    init(*args,  %kwargs) {
        @handle = thread.create(*args, **kwargs)
    }

    getName() {
        thread.getName()
    }

    setName(s) {
        thread.setName(s)
    }

    join(timeoutMs: ?Int) {
        thread.join(@handle, timeoutMs)
    }

    kill(sig) {
        thread.kill(@handle, sig)
    }

    detach() {
        thread.detach(@handle)
    }

    id(t) {
        thread.id(t)
    }
}

macro static! {
    let e = parse.expr(50)
    ty.Value(ty.eval(e))
}

macro showCode {
    let e = parse.stmt(0)
    print(e)
    e
}

macro match?(e, p) {
    if p != nil {
        $$[
            match $$e {
                $$p => true,
                _   => false
            }
        $$]
    } else {
        $$[
            (match {
                $$e => true,
                _   => false
            })
        $$]
    }
}

macro dbg(*args) {
    let tmp = ty.Id(name: ty.gensym())

    if #args == 0 {
        return $$[ nil $$]
    }

    ty.Block([
        *[
            $$[
                let $$(tmp) = $$(e)
                print(
                    __module__,
                    ':',
                    __func__ ?? '(top)',
                    ':',
                    __line__,
                    ': ',
                    $$(ty.String(parse.show(raw[i]))),
                    ' = ',
                    $$(tmp),
                    sep: '',
                    flush: true
                )
            $$]
            for e, i in args
        ],
        tmp
    ])
}

macro time! {
    // (
    lex.next()

    let (p, e) = parse.stmt(0, raw: true)

    // )
    lex.next()

    $$[{
        let now = $$(ty.Value(time.utime))
        let (s, x, e) = (now(), $$(e), now())

        print(
            __module__,
            ':',
            __line__,
            ': ',
            $$(ty.String(parse.show(p))),
            ': ',
            (e - s) / 1.0e6,
            's',
            sep: ''
        )

        x
    }$$]
}

macro timed(e) {
    lex.next()

    ty.Block([
        ty.Let(
            ty.Array([
                ty.ArrayItem(item: ty.Id(name: 's')),
                ty.ArrayItem(item: ty.Id(name: 'x')),
                ty.ArrayItem(item: ty.Id(name: 'e'))
            ]),
            ty.Array([
                ty.ArrayItem(item: ty.Call(func: ty.Value(time.utime), args: [])),
                ty.ArrayItem(item: e),
                ty.ArrayItem(item: ty.Call(func: ty.Value(time.utime), args: []))
            ])
        ),
        ty.Record([
            ty.RecordEntry(item: ty.Div(ty.Sub(ty.Id(name: 'e'), ty.Id(name: 's')), ty.Value(1.0e6))),
            ty.RecordEntry(item: ty.Id(name: 'x'))
        ])
    ])
}

macro modify! {
    function path() {
        let p = [lex.next().id]

        while lex.peek().type == '.' {
            lex.next()
            p.push(lex.next().id)
        }

        p
    }

    function convert(d) {
        let entries = []

        for k, v in d {
            entries.push(ty.RecordEntry(item: (v :: Dict) ? convert(v) : v, name: k))
        }

        ty.Record(entries)
    }


    let record = %{}

    // {
    lex.next()

    while lex.peek().type != '}' {
        let (p, [field]) = path().split(-1)

        // : or =
        lex.next()

        let e = ty.ImplicitFunc(body: parse.expr(0), params: [])

        let d = record

        for part in p {
            if part not in d {
                d[part] = %{}
            }
            d = d[part]
        }

        d[field] = e

        if lex.peek().type == ',' {
            lex.next()
        }
    }

    // }
    lex.next()

    convert(record)
}

function nextEnumValue(last) {
    let name = lex.next().id
    if lex.peek().type == '=' {
        lex.next()
        (name, parse.expr(0))
    } else {
        (name, ty.Add(last, ty.Int(1)))
    }
}

macro enum! {
    if lex.peek().type == '{' {
        lex.next()

        let vars = []
        let i = ty.Int(-1)

        while lex.peek().type != '}' {
            let (e, val) = nextEnumValue(i)
            vars.push(ty.Let(ty.Id(name: e), val))
            if lex.peek().type == ',' lex.next()
            i = val
        }

        lex.next()

        ty.Multi(vars)
    } else {
        let name = lex.next().id

        lex.next()

        let entries = []
        let i = ty.Int(-1)

        while lex.peek().type != '}' {
            let (e, val) = nextEnumValue(i)
            entries.push(ty.RecordEntry(item: val, name: e))
            if lex.peek().type == ',' lex.next()
            i = val
        }

        lex.next()

        ty.Let(ty.Id(name: name), ty.Record(entries))
    }
}

macro lock! {
    let mtx = parse.expr(0)
    let stmt = parse.stmt(0)
    ty.With(
        [ty.Let(
            ty.Id(name: '_'),
            ty.MethodCall(object: mtx, method: 'lock', args: [])
        )],
        stmt
    )
}

macro sync! {
    // (
    lex.next()

    let names = []

    while lex.peek().type != ')' {
        names.push(lex.next().id)
        if lex.peek().type == ',' {
            lex.next()
        }
    }

    // )
    lex.next()

    let body = parse.stmt(0)

    let locks = []
    let defs = []

    for name in names {
        locks.push(
            ty.Let(
                ty.Id(name: '_'),
                ty.Call(
                    func: ty.Value(Sync.lock),
                    args: [ty.Arg(arg: ty.Id(name: name))]
                )
            )
        )
        defs.push(
            ty.Let(
                ty.Id(name: name),
                ty.Call(
                    func: ty.Value(Sync.get),
                    args: [ty.Arg(arg: ty.Id(name: name))]
                )
            )
        )
    }

    ty.With(
        locks,
        ty.Block([
            *defs,
            body
        ])
    )
}

macro static_if {
    let (ty.Expr ~> cond, _) = parse.expr(0, raw: true)

    let (ty.Stmt ~> then, _) = parse.stmt(0, raw: true)

    let otherwise = if lex.peek().type == 'else' {
        lex.next()
        ty.Stmt(parse.stmt(0, raw: true)[0])
    }

    ty.CompileTime(ty.If([cond], ty.Value(then), ty.Value(otherwise ?? ty.Nil)))
}

macro ifdef {
    let v = lex.next()

    let then = parse.stmt(0)

    let otherwise = if lex.peek().type == 'else' {
        lex.next()
        parse.stmt(0)
    }

    ty.CompileTime(ty.If([ty.Defined(name: v.id, module: v.module)], ty.Value(then), ty.Value(otherwise ?? ty.Nil)))
}

class SharedQueue : Iterable {
    init(xs=[]) {
        @xs = []
        @i = 0
        @j = 0
        @mutex = Mutex()
        @cond = CondVar()

        for x in xs {
            self.put(x)
        }
    }

    __len__() {
        with @mutex.lock() {
            if @xs {
                (@j - @i + #@xs) % #@xs
            } else {
                0
            }
        }
    }

    countUnlocked() {
        if @xs {
            (@j - @i + #@xs) % #@xs
        } else {
            0
        }
    }

    empty?() {
        with @mutex.lock() {
            #self == 0
        }
    }

    put(x) {
        let notify = false

        with @mutex.lock() {
            if self.countUnlocked() == 0 {
                notify = true
            }

            if !@xs {
                @xs = [x, nil]
                @j = 1
            } else if (@j + 1) % #@xs == @i {
                let n = self.countUnlocked()
                @xs.rotate!(@i)
                @xs += @xs
                @i = 0
                @j = n + 1
                @xs[n] = x
            } else {
                @xs[@j] = x
                @j = (@j + 1) % #@xs
            }
        }

        @cond.signal()
    }

    tryTake(timeoutMs: Int = 0) {
        let stop = time.utime() + timeoutMs * 1000

        @mutex.lock()

        while self.countUnlocked() == 0 {
            let now = time.utime()

            if timeoutMs != -1 && now >= stop {
                @mutex.unlock()
                return None
            }

            let condTimeout = (timeoutMs == -1) ? -1 : (stop - now) / 1000

            @cond.wait(@mutex, condTimeout)
        }

        let x = @xs[@i]
        @i = (@i + 1) % #@xs

        @mutex.unlock()

        return Some(x)
    }

    take() {
        let Some(x) = self.tryTake()
        return x
    }

    __iter__*() {
        for let i = @i; i != @j; i = (i + 1) % #@xs {
            yield @xs[i]
        }
    }
}

function memoized(f) {
    let memo = %{*: f(*it.0, **%{k: v for (k, v) in it.1})}
    return function (*args, %kwargs) {
        let kwargs = kwargs.list().sort(by: &0)
        memo[(args, kwargs)]
    }
}

macro __walk! {
    function walk(tree, f) {
        if tree == nil { return nil }

        let tree = ty.copySource(tree, match tree {
            ty.Stop(tree) => tree,

            ty.Array(xs) => ty.Array([walk(x, f) for x in xs]),

            ty.ArrayItem(x) => ty.ArrayItem(
                item: walk(x.item, f),
                cond: walk(x.?cond, f),
                optional: x.?optional
            ),

            ty.Call(call) => ty.Call(
                func: walk(call.func, f),
                args: [walk(arg, f) for arg in call.args]
            ),

            ty.Arg(arg) => ty.Arg(
                arg: walk(arg.arg, f),
                cond: walk(arg.?cond, f),
                name: arg.?name
            ),

            ty.MethodCall(call) => ty.MethodCall(
                object: walk(call.object, f),
                args: [walk(arg, f) for arg in call.args],
                method: call.method
            ),

            ty.Record(record) => ty.Record([walk(entry, f) for entry in record]),

            ty.RecordEntry(entry) => ty.RecordEntry(
                item: walk(entry.item, f),
                name: entry.?name,
                cond: walk(entry.?cond, f),
                optional: entry.?optional
            ),

            ty.Add(a, b) => ty.Add(walk(a, f), walk(b, f)),
            ty.Mul(a, b) => ty.Mul(walk(a, f), walk(b, f)),
            ty.Div(a, b) => ty.Div(walk(a, f), walk(b, f)),
            ty.Sub(a, b) => ty.Sub(walk(a, f), walk(b, f)),
            ty.Mod(a, b) => ty.Mod(walk(a, f), walk(b, f)),
            ty.LT(a, b) => ty.LT(walk(a, f), walk(b, f)),
            ty.LEQ(a, b) => ty.LEQ(walk(a, f), walk(b, f)),
            ty.GT(a, b) => ty.GT(walk(a, f), walk(b, f)),
            ty.GEQ(a, b) => ty.GEQ(walk(a, f), walk(b, f)),
            ty.Cmp(a, b) => ty.Cmp(walk(a, f), walk(b, f)),
            ty.In(a, b) => ty.In(walk(a, f), walk(b, f)),
            ty.NotIn(a, b) => ty.NotIn(walk(a, f), walk(b, f)),

            ty.Range(a, b) => ty.Range(walk(a, f), walk(b, f)),
            ty.IncRange(a, b) => ty.IncRange(walk(a, f), walk(b, f)),

            ty.Func(func),
            ty.ImplicitFunc(func),
            ty.FuncDef(func) => type(tree)(
                name: func.name,
                decorators: [walk(dec, f) for dec in func.decorators],
                params: [walk(param, f) for param in func.params],
                rt: walk(func.rt, f),
                body: walk(func.body, f)
            ),

            ty.Param(param) => ty.Param(
                name: param.name,
                constraint: walk(param.constraint, f),
                default: walk(param.default, f)
            ),

            ty.Class(c) => ty.Class(
                name: c.name,
                super: walk(c.super, f),
                methods: [walk(m, f) for m in c.methods],
                getters: [walk(g, f) for g in c.getters],
                setters: [walk(s, f) for s in c.setters],
                statics: [walk(s, f) for s in c.statics]
            ),

            ty.Cond(cond, a, b) => ty.Cond(
                walk(cond, f),
                walk(a, f),
                walk(b, f)
            ),

            ty.If(conds, a, b) => ty.If(
                [walk(cond, f) for cond in conds],
                walk(a, f),
                walk(b, f)
            ),

            ty.IfNot(conds, a, b) => ty.IfNot(
                [walk(cond, f) for cond in conds],
                walk(a, f),
                walk(b, f)
            ),

            ty.Eq(a, b)    => ty.Eq(walk(a, f), walk(b, f)),
            ty.NotEq(a, b) => ty.NotEq(walk(a, f), walk(b, f)),
            ty.And(a, b)   => ty.And(walk(a, f), walk(b, f)),
            ty.Or(a, b)    => ty.Or(walk(a, f), walk(b, f)),

            ty.KwAnd(e, conds) => ty.KwAnd(
                walk(e, f),
                [walk(cond, f) for cond in conds]
            ),

            ty.UserOp(op, a, b) => ty.UserOp(
                op,
                walk(a, f),
                walk(b, f)
            ),

            ty.MemberAccess(object, member) => ty.MemberAccess(
                walk(object, f),
                member
            ),

            ty.Return(values) => ty.Return([walk(v, f) for v in values]),

            ty.Yield(values) => ty.Yield([walk(v, f) for v in values]),

            ty.Block(block) => ty.Block([walk(s, f) for s in block]),

            ty.Multi(multi) => ty.Multi([walk(s, f) for s in multi]),

            ty.While(conds, body) => ty.While(
                [walk(c, f) for c in conds],
                walk(body, f)
            ),

            ty.Each(each) => ty.Each(
                pattern: [walk(p, f) for p in each.pattern],
                iter: walk(each.iter, f),
                expr: walk(each.expr, f),
                cond: walk(each.cond, f)
            ),

            ty.For(init, cond, next, body) => ty.For(
                walk(init, f),
                walk(cond, f),
                walk(next, f),
                walk(body, f)
            ),

            ty.Match(subject, arms) => ty.Match(
                walk(subject, f),
                [(walk(pattern, f), walk(value, f)) for (pattern, value) in arms]
            ),

            ty.WhileMatch(subject, arms) => ty.WhileMatch(
                walk(subject, f),
                [(walk(pattern, f), walk(value, f)) for (pattern, value) in arms]
            ),

            ty.Defer(func) => ty.Defer(walk(func, f)),

            ty.Eval(code) => ty.Eval(walk(code, f)),

            ty.Throw(x) => ty.Throw(walk(x, f)),

            ty.Try({body, catches, always}) => ty.Try(
                body: walk(body, f),
                catches: [(walk(p, f), walk(h, f)) for (p, h) in catches],
                always: walk(always, f)
            ),

            ty.Break(b) => ty.Break(value: walk(b.value, f), depth: b.depth),

            ty.Dict(dict) => ty.Dict(
                items: [walk(item, f) for item in dict.items],
                default: walk(dict.default, f)
            ),

            ty.DictItem(a, b) => ty.DictItem(
                walk(a, f),
                walk(b, f)
            ),

            ty.Subscript(xs, i) => ty.Subscript(
                walk(xs, f),
                walk(i, f)
            ),

            ty.Generator(gen) => ty.Generator(walk(gen, f)),

            ty.ArrayCompr({items, pattern, iter, cond}) => ty.ArrayCompr(
                items: [walk(item, f) for item in items],
                pattern: walk(pattern, f),
                iter: walk(iter, f),
                cond: walk(cond, f)
            ),

            ty.Spread(spread) => ty.Spread(walk(spread, f)),
            ty.Splat (splat)  => ty.Splat (walk(splat, f)),

            ty.Count(xs) => ty.Count(walk(xs, f)),

            ty.Question(xs) => ty.Question(walk(xs, f)),

            ty.Not(x) => ty.Not(walk(x, f)),
            ty.Neg(x) => ty.Neg(walk(x, f)),

            ty.PreInc (x) => ty.PreInc (walk(x, f)),
            ty.PostInc(x) => ty.PostInc(walk(x, f)),
            ty.PreDec (x) => ty.PreDec (walk(x, f)),
            ty.PostDec(x) => ty.PostDec(walk(x, f)),

            ty.Let(target, x) => ty.Let(
                walk(target, f),
                walk(x, f)
            ),

            ty.Assign(target, x) => ty.Assign(
                walk(target, f),
                walk(x, f)
            ),

            ty.With(bindings, body) -> ty.With(
                [walk(binding, f) for binding in bindings],
                walk(body, f)
            ),

            ty.SpecialString(parts) => ty.SpecialString(
                [walk(part, f) for part in parts]
            ),

            ty.Wtf(a, b) => ty.Wtf(
                walk(a, f),
                walk(b, f)
            ),

            ty.TagPattern(id, pattern) => ty.TagPattern(
                id,
                walk(pattern, f)
            ),

            ty.Tagged(t, *xs) => ty.Tagged(
                walk(t, f),
                *(walk(x, f) for x in xs)
            ),

            ty.View(view, pattern) => ty.View(walk(view, f), walk(pattern, f)),
            ty.NotNilView(view, pattern) => ty.NotNilView(walk(view, f), walk(pattern, f)),

            _ => tree
        })

        return ty.copySource(tree, f(tree))
    }

    ty.Value(walk)
}

macro __desugar_partial__(call) {
    let (args, mkcall) = match call {
        %t({args, ?func, *call}) => do {
            if func == ty.Nil {
                func = ty.Value(x -> x)
            }
            (args, args -> t({*call, func, args}))
        }
    }

    args.map!(e -> __walk!(e, match {
        ty.Id({name: /^(_+)([xyz])$/, *})
            => ty.Id({name: _1 + str(' xyz'.search(_2))}),
        e   => e
    }))

    let depth = 0

    __walk!(call, match {
        ty.Id({name: /^(_+)\d*$/, *}) as e => do {
            depth = max(depth, #_1)
            e
        },

        e => e
    })

    // FIXME This doesn't work right now because it breaks on stuff like
    //          let id = 'foo'
    //  due to Id(name: 'id') being replaced with Value(<function 'id' at 0x0c482d4724>)
    //
    //  We need to distinguish between lvalues, patterns, ordinary exprs, etc.
    //  while walking the AST.
    //
    //  Even if this is fixed, does it make sense to eagerly evaluate here?
    /*
    args.map!(ty.Arg({arg, *rest}) -> ty.Arg({
        arg: __walk!(arg, e -> try { ty.Value(ty.eval(e)) } catch _ { e }),
        *rest
    }))
    */

    args.map!(e -> __walk!(e, match {
        ty.Id({name: /^(_+)(\d*)$/, *}) => ty.Id({name: '_'.repeat(depth - #_1 + 1) + _2}),
        e => e
    }))

    function go(args, mkcall, d) {
        if d == 0 {
            return mkcall(args)
        }

        let argvId = ty.gensym()
        let kwargsId = ty.gensym()

        let argv = ty.Id(name: argvId)
        let kwargs = ty.Id(name: kwargsId)

        let sliceArgs = []
        let add = arg -> do { sliceArgs.push(arg); arg }

        let i = 0
        let reducedArgs = args.map(e -> __walk!(e, match {
            ty.Id({name: '_', *})          => ty.Subscript(argv, ty.Int(i++)),
            ty.Id({name: /^_(\d+)$/, *})   => ty.Subscript(argv, ty.Int(int(_1) - 1)),
            ty.Id({name: /^_(_+\d*)$/, *}) => ty.Id({name: _1}),
            ty.Id({name: '**', *}) as e    => (d == 1) ? kwargs : ty.Add(kwargs, e),

            ty.Id({name: '*', *}) as e => do {
                let slice = ty.MethodCall({
                    object: argv,
                    method: 'slice',
                    args: [ty.Arg(add({arg: ty.Int(0)}))]
                })
                (d == 1) ? slice : ty.Add(slice, e)
            },

            e => e
        }))

        for arg in sliceArgs { arg.arg = ty.Int(i) }

        return ty.Func({
            params: [ty.Gather(argvId), ty.Kwargs(kwargsId)],
            body: go(reducedArgs, mkcall, d - 1)
        })
    }

    return go(args, mkcall, max(depth, 1))
}

operator **   10 right
operator <<   7  left
operator >>   7  left
operator ^    5  left
operator :>   5  left
operator !::  3  left
operator *>   2  left
