import os (terminal-size)
import ffi as c (C!)
import chalk (chalk)

class TooWideError {}
class TooMuchError {}
tag Stop;

let defaultColors = {
    dict:  chalk['#e78a4e bold'],
    array: chalk['#e78a4e bold'],
    str:   chalk['#a9b665'],
    quote: chalk['#a9b665 bold'],
    int:   chalk['#d3869b'],
    float: chalk['#d3869b'],
    null:  chalk['#89b482'],
    t:     chalk['#d8a657'],
    c:     chalk['#d8a657'],
    field: chalk['#7daea3'],
    bool:  chalk['#d3869b'],
    more:  chalk['#928374']
}

pub fn escapeString(s) {
    s.sub(/[\x00-\x1F\x7F-\xFF"\\]/, match {
        '"'  => '\\"',
        '\\' => '\\\\',
        '\b' => '\\b',
        '\f' => '\\f',
        '\n' => '\\n',
        '\r' => '\\r',
        '\t' => '\\t',
        c    => "\\x{c.byte(0):02x}"
    })
}

fn trunc(str, n) { str[;n].comb(/\x1b[[^m]+$/) }

class Printer {
    __width:    Int
    __indent:   Int
    __out:      Blob
    __col:      Int
    __depth:    Int
    __colors:   _
    __color:    Bool
    __visiting: Array[Any]
    __oneline:  Bool

    init(
        width:    Int  = 96,
        indent:   Int  = 2,
        colors:   Any  = defaultColors,
        color:    Bool = true,
        oneline:  Bool = false
    ) {
        __width    = width
        __indent   = indent
        __out      = Blob()
        __col      = 0
        __depth    = 0
        __colors   = colors
        __color    = color
        __visiting = []
        __oneline  = oneline
    }

    save() {
        (__col, __depth, #__visiting, #__out)
    }

    restore(state) {
        let (col, depth, num-visiting, i) = state
        __out.splice(i)
        __col = col
        __depth = depth
        __visiting.take!(num-visiting)
    }

    write(s: String, pen=id, force=false) {
        let want = #s
        let have = max(0, __width - __col)

        let off = __color ? "\x1b[0m" : ''

        fn put(x) {
            __out.push(str(__color ? pen(x) : x))
            __col += #x
        }

        match have {
            0 and __oneline   => throw Stop,
            _ and force       => put(s),
            n and (n >= want) => put(s),
            n and __oneline   => do { put(trunc(s, n)); __out.push(off) },
            _                 => throw TooWideError()
        }
    }

    nl(n=0) {
        __depth += n
        __out.push('\n')
        __col = 0
        write(' '.repeat(__indent * __depth), force=true)
    }

    go(x: _, canPush: ?Bool = false, force: ?Bool = false) {
        let id-of-x = ident(x)

        if id-of-x in __visiting {
            write('...', __colors.more, force)
            return
        }

        __visiting.push(id-of-x)

        let state = save()

        let force! = force && !canPush

        fn printList(xs, open, close, color) {
            try {
                write(open, color, force!)
                for (f, x) in ((go, x) for x in xs).intersperse((write, ', ')) {
                    f(x, force=force!)
                }
                write(close, color, force!)
            } catch (e: TooWideError) and canPush {
                restore(state)
                write(open, color, force)
                nl(1)
                for x, i in xs {
                    if i > 0 { write(',', id, force); nl() }
                    go(x, true, force)
                }
                nl(-1)
                write(close, color, force)
            }
        }

        fn printMap(
            m: Array[(_, _)],
            open: String,
            close: String,
            eq: String,
            field-style=__colors.field,
            delim-style=__colors.dict
        ) {
            let write-key = match open {
                '%{' => go,
                _    => write@($1, field-style, $3)
            }

            try {
                write(open, delim-style, force!)
                for match m.intersperse(', ') {
                    (k, v) => {
                        write-key(k, false, force!)
                        write(eq, delim-style, force!)
                        go(v, false, force!)
                    },

                    s => {
                        write(s, id, force!)
                    }
                }
                write(close, delim-style, force!)
            } catch (e: TooWideError) and canPush {
                restore(state)
                write(open, delim-style, force)
                nl(1)
                for (k, v), i in m {
                    if i > 0 { write(',', id, force); nl() }
                    write-key(k, true, force)
                    write(eq, delim-style, force)
                    go(v, true, force)
                }
                nl(-1)
                write(close, delim-style, force)
            }
        }

        match x {
            xs :: Array => {
                printList(xs, '[', ']', __colors.array)
            },

            d :: Dict => {
                printMap(d.list(), '%{', '}', ': ')
            },

            %t(x) => {
                write("{t}(", __colors.t, force)
                go(x, canPush, force)
                write(")", __colors.t, force)
            },

            t :: Tuple => {
                let items = members(t, list: true)

                if items.map(&0) :: Array[Int] {
                    printList(items.map(&1), '(', ')', __colors.array)
                } else {
                    printMap(items, '{', '}', ': ')
                }
            },

            nil => {
                write('nil', __colors.null, force)
            },

            _ :: String => {
                let s = escapeString(x)
                write('"', __colors.quote, force)
                write(s, __colors.str, force)
                write('"', __colors.quote, force)
            },

            _ :: Bool => {
                write("{x}", __colors.bool, force)
            },

            _ :: Int => {
                write("{x}", __colors.int, force)
            },

            _ :: Float => {
                write("{x}", __colors.float, force)
            },

            members@(_, list=true) ~> $ms => {
                printMap(ms, "{type(x).__name__}(", ')', '=', delim-style=__colors.c)
            },

            _ => {
                write(show(x), id, force)
            }
        }

        __visiting.pop()
    }

    print(x: _) {
        try {
            restore((0, 0, 0, 0))
            go(x, true, true)
        } catch Stop { // Truncated
            __out.push('...')
        }
        __out.str()
    }
}

fn term-cols() -> Int {
    terminal-size().?cols ?? 80
}

pretty = fn pretty(x, %kwargs) {
    kwargs['width'] ?= max(min(term-cols(), 108), 36)
    Printer(**kwargs).print(x)
}

pp = fn prettyPrint(x, %kwargs: Any) {
    print(pretty(x, **kwargs))
}
