import termkey (..)
import errno
import ffi as c (C!)
import os (..)
import sh (sh)
import ioctls (..)

let ERASE_LINE = "\x1b[2K"

let tk = nil
let defaultPrompt = nil
let defaultComplete = nil
let termFd = nil

let history = []

tag CycleCompletions, ListCompletions, ReplaceLine, Insert;

class CompletionCycler {
    init(cs, line, i) {
        @i = i
        @line = line
        @cs = cs
        @ci = -1
    }

    cycle() {
        if #@cs == 0 || @ci + 1 == #@cs {
            @ci = -1
            return (@line, @i)
        }

        @ci = (@ci + 1) % #@cs

        let c = @cs[@ci]

        let line = @line.clone()
        line.insert(@i, c)

        return (line, @i + 1)
    }
}

C! struct WinSize {
    c.short lines;
    c.short cols;
    c.short xpix;
    c.short ypix;
}

let winSize = WinSize()

pub function init(fd=0, prompt=nil, complete=nil, ctrl_c=false) {
    termFd = fd
    defaultPrompt = prompt
    defaultComplete = complete
    if !(tk = termkey_new(fd, ctrl_c ? TERMKEY_FLAG_CTRLC : 0)) {
        throw Err(errno.get())
    }
}

function termDimensions() {
    ioctl(termFd, TIOCGWINSZ, (c.ptr, winSize.get()))
    return (winSize.lines(), winSize.cols())
}

function completeFile(before, after) {
    let parts = (before.match!(/'[^']*$/) ?? before.match!(/\S*$/)).comb(/'/).split('/')

    let (dir, prefix) = match parts {
        [prefix] => ('.', prefix),
        [*parts, prefix] => (parts.join('/'), prefix)
    }

    let names = sh("find -s '{dir}' -maxdepth 1 -name '{prefix}*'").lines().filter(${#it > 0}).map!(&comb(/^\.\//))

    let chop = &slice(#"{dir}/{prefix}".comb(/^\.\//))

    return match names {
        []       => None,
        [unique] => Insert(chop(unique)),
        _        => CycleCompletions(names.map(chop)),
        _        => ListCompletions(names)
    }

}

function fitItems(items, W) {
    function widths(cols) {
            items.map(&len).groupsOf(#items / cols).map(&max)
    }

    let (cols, ws) = for cols in 1..#items {
            let ws = widths(cols + 1)
            if ws.sum() + 2 * cols > W {
                    break (cols, widths(cols))
            }
    } ?? (#items, widths(#items))

    let cols = items.groupsOf(#items / cols)
    let rows = cols.map(&len).max()

    let result = []

    for i in ..rows {
            result.push(cols.map(c -> #c > i ? c[i] : '').zip(ws, (f, w) -> f.padRight(w)).join('  '))
    }

    result
}

pub function readln(prompt=nil, complete=nil, erase=true) {
    if tk == nil {
        init()
    }

    let prompt = prompt ?? defaultPrompt
    let line = []
    let i = 0

    function getBefore() {
        line.slice(0, i).str() ?? ''
    }

    function getAfter() {
        line.slice(i).str() ?? ''
    }

    function getText() {
        line.str() ?? ''
    }

    let pKey = c.new(TermKeyKey)
    let keyBuffer = Blob()
    
    keyBuffer.reserve(256)

    termkey_start(tk)

    defer termkey_stop(tk)

    let hi = 0
    let hPrefix = nil
    let hSuffix = nil

    let completionCycler = nil

    function hMatch?(i) {
        if #history < i { return false }
        let text = history[-i].0.str() ?? ''
        text.starts?(hPrefix) && text.ends?(hSuffix)
    }

    while true {
        let before = line.slice(0, i).str() ?? ''
        let all = line.str() ?? ''

        write(1, "{ERASE_LINE}\r{prompt}{all}\r{prompt}{before}")

        termkey_waitkey(tk, pKey)
        termkey_strfkey(tk, keyBuffer, 256, pKey, TERMKEY_FORMAT_VIM)

        let key = c.as_str(keyBuffer.ptr())

        let hiStart = hi

        if key != '<Tab>' {
            completionCycler = nil
        }

        match key {
            '<Enter>' => {
                let text = getText()

                if text != '' && (history == [] || (line, i) != history[-1]) {
                    history.push((line, i))
                }

                if erase {
                    write(1, "{ERASE_LINE}\r")
                } else {
                    write(1, '\n')
                }

                return text
            },

            '<C-d>' => {
                return nil
            },

            '<C-a>' => {
                i = 0
            },

            '<C-e>' => {
                i = #line
            },

            '<C-k>' => {
                line.take!(i)
            },

            '<C-l>' => {
                write(1, "\x1b[2J\x1b[H")
            },

            '<C-w>' => {
                while i > 0 && line[i - 1].match?(/^\S*$/) {
                    line.pop(--i)
                }
                while i > 0 && line[i - 1].match?(/^\s*$/) {
                    line.pop(--i)
                }
            },

            '<Left>' => {
                if i > 0 {
                    i -= 1
                }
            },

            '<Right>' => {
                if i < #line {
                    i += 1
                }
            },

            '<Up>' => {
                hPrefix ?= getBefore()
                hSuffix ?= getAfter()

                while hi < #history {
                    hi += 1
                    if hMatch?(hi) {
                        break
                    }
                }

                if hi < #history && !hMatch?(hi) {
                    hi = hiStart
                }
            },

            '<Down>' => {
                hi -= 1

                while hi > 0 && !hMatch?(hi) {
                    hi -= 1
                }

                if (hi < 0) || (hi > 0 && !hMatch?(hi)) {
                    hi = 0
                }
            },

            '<DEL>', '<Backspace>' => {
                if i > 0 {
                    line.pop(--i)
                }
            },

            '<Tab>' => {
                if completionCycler != nil {
                    (line, i) = completionCycler.cycle()
                } else {
                    let (before, after) = line.split(i)
                    let result = (complete ?? defaultComplete ?? completeFile)(before.str() ?? '', after.str() ?? '')
                    match result {
                        Insert(s) => {
                            line.insert(i++, s)
                        },

                        None => {
                        },

                        ReplaceLine(s) => {
                            line = s.chars()
                            i = #line
                        },

                        CycleCompletions(cs) => {
                            completionCycler = CompletionCycler(cs, line, i)
                            (line, i) = completionCycler.cycle()
                        },

                        ListCompletions(cs) => {
                            write(1, "{ERASE_LINE}\r")

                            let (h, w) = termDimensions()

                            for line in fitItems(cs, w) {
                                print(line)
                            }
                        }
                    }
                }
            },

            '<C-r>' => {
                let fzf = spawn(['fzf', '--tac', '--no-sort', '-q', getText()], shareStdin: false, shareStderr: true)

                write(fzf.stdin, history.map(&0 |> &str).unlines())
                close(fzf.stdin)

                let out = read(fzf.stdout, 8192).str().strip()
                close(fzf.stdout)

                if #out > 0 {
                    line = out.chars()
                    i = #line
                }
            },

            ch => {
                line.insert(i++, ch.clone())
            }
        }

        if hi != hiStart {
            if hi == 0 {
                line = []
                i = 0
                hi = 0
            } else {
                (line, i) = history[-hi]
                line = line.clone()
            }
        } else if key != '<Up>' {
            hi = 0
            hPrefix = nil
            hSuffix = nil
        }
    }
}

function progressString(progress: Float, width: Int) {
    let progress = progress.clamp(0.0, 1.0)
    let wholeWidth = floor(progress * width)
    let remainderWidth = (progress * width) - wholeWidth
    let partWidth = floor(remainderWidth * 8)
    let partChar = [' ', '▏', '▎', '▍', '▌', '▋', '▊', '▉'][partWidth]

    if width - wholeWidth - 1 < 0 {
        partChar = ''
    }

    return "[{'█'.repeat(wholeWidth)}{partChar}{' '.repeat(width - wholeWidth - 1)}]"
}

pub function progress(work, prefix, width, effects=id, cleanup=false) {
    if tk == nil {
        init()
    }

    for p in work {
        let w = width ?? (termDimensions().1 - 8).clamp(0, 70)
        write(termFd, "\r{prefix ?? ''}{effects(progressString(p, w))} {p * 100#.1f}%%")
    }

    if cleanup {
        write(termFd, "{ERASE_LINE}\r")
    }
}
