import term (TermIO)
import errno
import ffi as c (C!)
import os (..)
import sh (sh)
import ioctls (..)
import json
import time
import chalk (chalk)
import path (Path)

let ERASE_LINE = "\x1b[2K"

let __tls::reader: ?InteractiveLineReader = nil

pub tag CycleCompletions, ListCompletions, ReplaceLine, Insert;

use Text = String | chalk::Text

pub use CompletionLabel = Text | Array[Text | nil]

pub use CompletionItem = String | (CompletionLabel, String);

pub use CompletionAction = CycleCompletions[Array[CompletionItem]]
                         | ListCompletions[Array[CompletionItem]]
                         | Insert[String]
                         | ReplaceLine[String]
                         | None

pub use CompletionFunction = {before: String, after: String} -> CompletionAction;

fn completion-label(item: CompletionItem) -> CompletionLabel {
    (item :: String) ? item : item.0
}

fn completion-text(item: CompletionItem) -> String {
    match item {
        (_, s) => s,
        s      => s
    }
}

class CompletionCycler {
    __line:  Array[String]
    __i:     Int
    __cs:    Array[CompletionItem]
    __ci:    Int
    __first: Bool

    init(cs: [String], line: [String], i: Int) {
        __i = i
        __line = line
        __cs = cs
        __ci = -1
        __first = true
    }

    items -> [CompletionItem] {
        __cs
    }

    cycle() {
        if (#__cs == 0) || (__ci + 1 == #__cs) {
            __ci = -1
            return (__line, __i)
        }

        __ci = (__ci + 1) % #__cs

        let c = completion-text(__cs[__ci])

        let line = __line.clone()
        line.insert(__i, c)

        return (line, __i + 1)
    }
}

fn completeFile(before: String, after: String) -> CompletionAction {
    let parts = (before.match!(/'[^']*$/) ?? before.match!(/\S*$/)).comb(/'/).split('/')

    let (dir, prefix) = match parts {
        [prefix] => ('.', prefix),
        [*parts, prefix] => (parts.join('/'), prefix)
    }

    if not let $output = sh("find -s '{dir}' -maxdepth 1 -name '{prefix}*'") {
        return None
    }

    let names = output
        .lines()
        .filter(${#it > 0})
        .map!(&comb(/^\.\//))

    let chop = &slice(#"{dir}/{prefix}".comb(/^\.\//))

    return match names {
        []       => None,
        [unique] => Insert(chop(unique)),
        _        => CycleCompletions(names.map(chop))
    }
}

fn fitItems(items: Array[CompletionLabel], W: Int) {
    fn plain(item: CompletionLabel) -> String {
        let item = match item {
            parts: Array[Text | nil] => parts
                .map(part -> part ?? '')
                .str(),

            part => str(part)
        }

        (chalk"{item}").plain
    }

    let items = items.sort(by=plain)

    fn width(text: Text | nil) -> Int {
        (text == nil) ? 0 : "{text}".width()
   }

    fn widths(ncols: Int) -> Array[Array[Int]] {
        let cols = items.groupsOf(#items / ncols)
        
        fn col-widths(i: Int) -> Array[Int] {
            let nparts = cols[i]
                .map(label -> (label :: Array) ? #label : 1)
                .max()

            let parts: Array[Int] = []

            fn limit() -> Int {
                W - (parts.sum() ?? 0)
            }

            for j in ..nparts {
                let w = cols[i]
                    .map(match {
                        (label :: Array) and (#label > j)
                            => min(limit(), width(cast(label)[j])),

                        label and (j == 0)
                            => min(limit(), width(label)),

                        _ => 0
                    })
                    .max()
                parts.push(w ?? 0)
            }

            parts
        }

        [col-widths(it) for ..ncols]
    }

    let (cols, ws) = (
        for cols in 1..#items {
            let ws = widths(cols + 1)
            if ws.flat().sum() + 6 * cols > W {
                break (cols, widths(cols))
            }
        }
    ) ?? (#items, widths(#items))

    let cols: [[CompletionLabel]] = items.groupsOf(#items / cols)
    let rows: Int = cols.map(&len).max()

    let result = []

    fn format(label: CompletionLabel, widths: Array[Int]) -> String {
        match label {
            parts: Array[Text | nil] => [
                "{str(parts[i]):<{widths[i]}}"
                for i in ..#parts
            ].str(),

            part => "{str(part):<{widths.sum()}}"
        }
    }

    for i in ..rows {
        result.push(
            cols.map(c -> (#c > i) ? c[i] : '')
                .zip(ws, format)
                .join('    ')
        )
    }

    result
}

class InteractiveLineReader {
    __tio: TermIO
    __history_file: Path | nil
    __history: Array[(Array[String], Int)]
    __prompt: String
    __complete: CompletionFunction | nil
    __render: (String, [String], Int) -> String

    init(
        term: Int | TermIO = 0,
        prompt=nil,
        complete=nil,
        ctrl_c: ?Bool = false,
        history-file: Path | String | nil = nil,
        render: ((String, [String], Int) -> String) | nil = nil
    ) {
        __tio = match term {
            fd: Int => TermIO(fd, mouse=false),
            tio     => tio
        }

        __prompt = prompt ?? '>> '
        __complete = complete
        __history_file = (history-file != nil) ?: Path(history-file)

        if history-file != nil and let $raw = slurp("{history-file}") {
            __history = [(line, i) for json::parse! ~> {line, i, *} in raw.lines()]
        } else {
            __history = []
        }

        __render = render ?? fn (
            prompt: String,
            line: [String],
            i: Int
        ) -> String {
            let before = line.slice(0, i).str() ?? ''
            let all = line.str() ?? ''
            return "{prompt}{all}\r{prompt}{before}"
        }
    }

    __add_history(entry: (Array[String], Int)) {
        if __history_file != nil {
            let record = {line: entry.0, i: entry.1, t: time.utc()}
            __history_file.parent.mkdir(parents=true, exist-ok=true)
            __history_file.append("{json::encode(record)}\n")
        }

        __history.push(entry)
    }

    readln(
        prompt: ?String = nil,
        complete: _ = nil,
        erase: Bool = false,
        keybinds: Dict[String, _] = %{},
        render: (String, [String], Int) -> String = nil
    ) -> String | nil {
        if __tio == nil {
            init()
        }

        let prompt = prompt ?? __prompt
        let render = render ?? __render
        let line = []
        let i = 0

        fn getBefore() {
            line.slice(0, i).str() ?? ''
        }

        fn getAfter() {
            line.slice(i).str() ?? ''
        }

        fn getText() {
            line.str() ?? ''
        }

        fn printItems(cs) {
            write(__tio.fd, "{ERASE_LINE}\rAvailable completions:\n")

            let (h, w) = __tio.size()

            for line in fitItems(cs, w) {
                print(line)
            }
        }

        __tio.start()
        defer __tio.stop()

        let hi = 0
        let hPrefix = nil
        let hSuffix = nil

        let completionCycler = nil

        fn hMatch?(i) {
            if #__history < i { return false }
            let text = __history[-i].0.str() ?? ''
            text.starts?(hPrefix) && text.ends?(hSuffix)
        }

        while true {
            let before = line.slice(0, i).str() ?? ''
            let all = line.str() ?? ''

            write(__tio.fd, "{ERASE_LINE}\r{render(prompt, line, i)}")

            if not let $key = __tio.next-event() {
                continue
            }

            let key = match key {
                term.event.Text(_) as t
                    => t,
                term.event.Key({event: 1 or 2, *})
                    => "<{key.nice-name()}>",
                _
                    => do continue
            }

            if key :: String and let $func = keybinds[key] {
                func(*__tio.size())
            }

            let hiStart = hi

            if key != '<Tab>' {
                completionCycler = nil
            }

            match key {
                '<Enter>', '\n' => {
                    let text = getText()

                    if text != '' && (__history == [] || (line, i) != __history[-1]) {
                        __add_history((line, i))
                    }

                    if erase {
                        write(__tio.fd, "{ERASE_LINE}\r")
                    } else {
                        write(__tio.fd, '\n')
                    }

                    return text
                },

                '<C-d>' => {
                    return nil
                },

                '<C-a>' => {
                    i = 0
                },

                '<C-e>' => {
                    i = #line
                },

                '<C-k>' => {
                    line.take!(i)
                },

                '<C-l>' => {
                    write(__tio.fd, "\x1b[2J\x1b[H")
                },

                '<C-w>' => {
                    while i > 0 && line[i - 1].match?(/^\S*$/) {
                        line.pop(--i)
                    }
                    while i > 0 && line[i - 1].match?(/^\s*$/) {
                        line.pop(--i)
                    }
                },

                '<Left>' => {
                    if i > 0 {
                        i -= 1
                    }
                },

                '<Right>' => {
                    if i < #line {
                        i += 1
                    }
                },

                '<Up>' => {
                    hPrefix ?= getBefore()
                    hSuffix ?= getAfter()

                    while hi < #__history {
                        hi += 1
                        if hMatch?(hi) {
                            break
                        }
                    }

                    if hi < #__history && !hMatch?(hi) {
                        hi = hiStart
                    }
                },

                '<Down>' => {
                    hi -= 1

                    while hi > 0 && !hMatch?(hi) {
                        hi -= 1
                    }

                    if (hi < 0) || (hi > 0 && !hMatch?(hi)) {
                        hi = 0
                    }
                },

                '<DEL>',
                '<Backspace>',
                '<S-Backspace>',
                '<C-Backspace>' => {
                    if i > 0 {
                        line.pop(--i)
                    }
                },

                '<Tab>' => {
                    if completionCycler != nil {
                        (line, i) = completionCycler.cycle()
                    } else {
                        let (before, after) = line.split(i)
                        let result = (
                               complete
                            ?? __complete
                            ?? completeFile
                        )(
                            before.str() ?? '',
                            after.str() ?? ''
                        )
                        match result {
                            Insert(s) => {
                                line.insert(i++, s)
                            },

                            ReplaceLine(s) => {
                                line = s.chars()
                                i = #line
                            },

                            CycleCompletions(cs) and #cs > 0 => {
                                completionCycler = CompletionCycler(cs, line, i)
                                (line, i) = completionCycler.cycle()
                                printItems(cs.map(completion-label))
                            },

                            ListCompletions(cs) and #cs > 0 => {
                                printItems(cs.map(completion-label))
                            },

                            _ => {}
                        }
                    }
                },

                '<C-r>' => {
                    __tio.stop()

                    let fzf = spawn(
                        ['fzf', '--tac', '--no-sort', '-q', getText()],
                        stdin=SPAWN_PIPE,
                        stdout=SPAWN_PIPE,
                        stderr=SPAWN_INHERIT
                    )

                    write(fzf.stdin, __history.map(\_.0.str()).unlines())
                    close(fzf.stdin)

                    let out = read(fzf.stdout, 8192).str().strip()
                    close(fzf.stdout)
                    waitpid(fzf.pid)

                    __tio.start()

                    if out {
                        line = out.chars()
                        i = #line
                    }
                },

                '<C-x>' => {
                    let (fd, tmp) = mktemp()
                    close(fd)

                    __tio.stop()

                    let editor = spawn([getenv('EDITOR') ?? 'vi', tmp])
                    waitpid(editor.pid)

                    __tio.start()

                    let out = slurp(tmp).comb(/\r/).sub(/\n+/, ' ').trim()
                    if #out > 0 {
                        line = out.chars()
                        i = #line
                    }
                },

                term.event.Text(s) => {
                    line.insert(i++, s)
                },

                _ => {}
            }

            if hi != hiStart {
                if hi == 0 {
                    line = []
                    i = 0
                    hi = 0
                } else {
                    (line, i) = __history[-hi]
                    line = line.clone()
                }
            } else if key != '<Up>' {
                hi = 0
                hPrefix = nil
                hSuffix = nil
            }
        }
    }

    progress(work, prefix, width, effects=id, cleanup=false) {
        for p in work {
            let w = width ?? (__tio.size().1 - 8).clamp(0, 70)
            write(__tio.fd, "\r{prefix ?? ''}{effects(progressString(p, w))} {p * 100:.1f}%%")
        }

        if cleanup {
            write(__tio.fd, "{ERASE_LINE}\r")
        }
    }
}

fn progressString(progress: Float, width: Int) {
    let progress = progress.clamp(0.0, 1.0)
    let wholeWidth = floor(progress * width)
    let remainderWidth = (progress * width) - wholeWidth
    let partWidth = floor(remainderWidth * 8)
    let partChar = [' ', '▏', '▎', '▍', '▌', '▋', '▊', '▉'][partWidth]

    if width - wholeWidth - 1 < 0 {
        partChar = ''
    }

    return "[{'█'.repeat(wholeWidth)}{partChar}{' '.repeat(width - wholeWidth - 1)}]"
}

pub fn progress(work, prefix, width, effects=id, cleanup=false) {
    reader = reader ?? InteractiveLineReader()
    reader.progress(work, prefix, width, effects=effects, cleanup=cleanup)
}

pub fn readln(
    prompt: ?String = nil,
    complete: _ = nil,
    erase: Bool = false,
    keybinds: Dict[String, _] = %{},
    render: (String, [String], Int) -> String = nil
) -> String | nil {
    reader = reader ?? InteractiveLineReader()
    reader.readln(
        prompt=prompt,
        complete=complete,
        erase=erase,
        keybinds=keybinds,
        render=render
    )
}
