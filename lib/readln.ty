import term (TermIO)
import errno
import ffi as c (C!)
import os (..)
import sh (sh)
import ioctls (..)
import json
import time
import chalk (chalk)
import path (Path)

let ERASE_LINE = "\x1b[2K"
let ERASE_REST = "\x1b[0J"

let __tls::reader: ?InteractiveLineReader = nil

pub tag CycleCompletions, ListCompletions, ReplaceLine, Insert;

use Text = String | chalk::Text

pub use CompletionLabel = Text | Array[Text | nil]

pub use CompletionItem = String | (CompletionLabel, String);

pub use CompletionAction = CycleCompletions[Array[CompletionItem]]
                         | ListCompletions[Array[CompletionItem]]
                         | Insert[String]
                         | ReplaceLine[String]
                         | None

pub use CompletionFunction = {before: String, after: String} -> CompletionAction;

pub use Prompt = String | (() -> String)

pub use RenderFunction = {
    prompt: String,
    lines: Array[Array[String]],
    line: Int,
    col: Int
} -> (Array[String], Int, Int);

use HistoryEntry = {
    lines: Array[Array[String]],
    i: Int,
    j: Int,
    t: Float
};

fn completion-label(item: CompletionItem) -> CompletionLabel {
    (item :: String) ? item : item.0
}

fn completion-label-plain(item: CompletionItem) -> String {
    let label = completion-label(item)

    let label = match label {
        parts: Array[Text | nil]
            => parts.remove(nil).join(),
        part
            => str(part)
    }

    (chalk"{label}").plain
}

fn completion-text(item: CompletionItem) -> String {
    match item {
        (_, s) => s,
        s      => s
    }
}

class CompletionCycler {
    __line:   Array[String]
    __i:      Int
    __cs:     Array[CompletionItem]
    __ci:     Int
    __first:  Bool
    __pages:  Array[Array[Array[String]]]
    __limits: {rows: Int, cols: Int}

    init(cs: Array[CompletionItem], line: Array[String], i: Int) {
        __i = i
        __line = line
        __cs = cs
        __ci = 0
        __first = true
        __pages = []
        __limits = terminal-size()!

        let rows = fit-items(__cs.map(completion-label), __limits.cols)
        let max-height = (__limits.rows - 8).clamp(1, 32)

        while rows {
            let page = []
            let height = 0

            while rows and (height < max-height) {
                let row = rows.pop(0)
                let width = __join(row).width()
                height += 1 + (width / (__limits.cols + 1))
                page.push(row)
            }

            __pages.push(page)
        }
    }

    static __join(row: Array[String]) -> String {
        row.join("\x1b[0m    ")
    }

    __seek(ci: Int) -> (Int, Int) {
        let n = 0
        for page, i in __pages {
            let count = page.map(`#`).sum()
            if ci < n + count {
                return (i, n)
            }
            n += count
        }
    }

    items -> Array[CompletionItem] {
        __cs
    }

    cycle() {
        if __ci == #__cs {
            __ci = 0
            return (__line, __i)
        }

        let text = completion-text(__cs[__ci])
        let line = __line.clone()
        line.insert(__i, text)

        __ci += 1

        (line, __i + 1)
    }

    render() {
        let out = Blob()

        out.push("{ERASE_REST}\n")

        let ci = (__ci % #__cs)

        let (pg-num, pg-start) = __seek(ci)

        let page = __pages[pg-num]

        let i = (ci - pg-start) % #page
        let j = (ci - pg-start) / #page

        let off = 0

        for row, row-i in page {
            if (i == row-i) && (__ci < #__cs) {
                row = [*row]
                row[j] = chalk"[reverse]{row[j]}[/]"
            }

            let line = row.join("\x1b[0m    ")

            off += line.width() / (__limits.cols + 1)

            out.push("{line}\n")
        }

        if #__pages > 1 {
            out.push("\nPage {pg-num + 1} of {#__pages}\n")
            off += 2
        }

        out.push("\r\x1b[{#page + off + 1}A")

        out.str!()
    }

    cursor -> Int {
        (__ci + 1) % #__cs
    }
}

fn completeFile(before: String, after: String) -> CompletionAction {
    let path-prefix = (before.match!(/'[^']*$/) ?? before.match!(/\S*$/))!
    let parts = path-prefix.comb(/'/).split('/')

    let (dir, prefix) = match parts {
        [prefix] => ('.', prefix),
        [*parts, prefix] => (parts.join('/'), prefix)
    }

    if not let $output = sh("find -s '{dir}' -maxdepth 1 -name '{prefix}*'") {
        return None
    }

    let names: Array[String] = output
        .lines()
        .filter(${#it > 0})
        .map!(&comb(/^\.\//))

    let chop = &slice(#"{dir}/{prefix}".comb(/^\.\//))

    match names {
        []       => None,
        [unique] => Insert(chop(unique)),
        _        => CycleCompletions(names.map(chop))
    }
}

fn fitItems(items: Array[CompletionLabel], W: Int) -> Array[Array[String]] {
    fn width(text: Text | nil) -> Int {
        (text == nil) ? 0 : "{text}".width()
    }

    fn group-cols(n: Int) -> Array[Array[CompletionLabel]] {
        items.groups-of((#items + n - 1) / n)
    }

    fn widths(ncol: Int) -> Array[Array[Int]] {
        let cols = group-cols(ncol)

        fn col-widths(i: Int) -> Array[Int] {
            if i >= #cols {
                return []
            }

            let nparts = cols[i]
                .map(label -> (label :: Array) ? #label : 1)
                .max()

            let parts: Array[Int] = []

            fn limit() -> Int {
                W - (parts.sum() ?? 0)
            }

            let max-singleton = 0

            for j in ..nparts {
                let w = cols[i].map(match {
                    (label: Array[Text | nil]) and (#label > j)
                        => min(limit(), width(label[j])),

                    label and (j == 0) => do {
                        max-singleton = max(
                            max-singleton,
                            min(limit(), width(label))
                        )

                        0
                    },

                    _ => 0
                }).max()
                parts.push(w || max-singleton)
            }

            parts
        }

        [col-widths(it) for ..ncol]
    }

    let (ncol, ws) = (
        for ncol in 1..#items {
            let ws = widths(ncol + 1)
            if ws.flat().sum(0) + 6 * ncol > W {
                break (ncol, widths(ncol))
            }
        }
    ) ?? (#items, widths(#items))

    let cols: [[CompletionLabel]] = group-cols(ncol)
    let nrow: Int = cols.map(&len).max()

    fn s(x: Text | nil) -> String {
        match x {
            x: String => x,
            nil       => '',
            _         => "{x}"
        }
    }

    fn format(label: CompletionLabel, widths: Array[Int]) -> String {
        match label {
            parts: Array[Text | nil] => [
                "{s(parts[i]):<{widths[i]}}"
                for i in ..#parts
            ].str() ?? '',

            part => "{s(part):<{widths.sum()}}"
        }
    }

    let x = cols.map(c -> (#c > 0) ? c[0] : '').zip(ws, f=format)

    return [
        cols.map(c -> (#c > i) ? c[i] : '').zip(ws, f=format)
        for i in ..nrow
    ]
}

class InteractiveLineReader {
    __tio: TermIO
    __borrowed-tio?: Bool
    __history-file: Path | nil
    __history: Array[HistoryEntry]
    __prompt: Prompt
    __complete: CompletionFunction | nil
    __render: RenderFunction

    init(
        term: Int | TermIO = 0,
        prompt=nil,
        complete=nil,
        ctrl_c: ?Bool = false,
        history-file: Path | String | nil = nil,
        render: RenderFunction | nil = nil
    ) {
        match term {
            tio: TermIO => {
                __tio = tio
                __borrowed-tio? = true
            },
            fd => {
                __tio = TermIO(fd, mouse=false)
                __borrowed-tio? = false
            }
        }

        __prompt = prompt ?? '>> '
        __complete = complete
        __history-file = (history-file != nil) ?: Path(history-file)

        if history-file != nil and let $raw = slurp("{history-file}") {
            __history = raw.lines().map(json::parse!)
        } else {
            __history = []
        }

        __render = render ?? fn (
            prompt: String,
            lines: Array[Array[String]],
            line: Int,
            col: Int
        ) -> (Array[String], Int, Int) {
            (lines.map(\_.str() ?? ''), line, col)
        }
    }

    __add-history(lines: Array[Array[String]], i: Int, j: Int) {
        let entry = {lines, i, j, t: time.utc()}

        if __history-file != nil {
            __history-file.parent.mkdir(parents=true, exist-ok=true)
            __history-file.append("{json::encode(entry)}\n")
        }

        __history.push(entry)
    }

    _get-prompt() -> String {
        match __prompt {
            p: String => p,
            f         => f()
        }
    }

    readln(
        prompt: String | nil = nil,
        complete: _ = nil,
        erase: Bool = false,
        keybinds: Dict[String, _] = %{},
        render: RenderFunction | nil = nil
    ) -> String | nil {
        if __tio == nil {
            init()
        }

        let prompt = prompt ?? _get-prompt()
        let render = render ?? __render

        let lines = [[]]
        let nr = 0

        let line = []
        let i = 0

        fn getBefore() {
            line.slice(0, i).str() ?? ''
        }

        fn getAfter() {
            line.slice(i).str() ?? ''
        }

        fn getText() {
            lines.map(\_.str() ?? '').unlines()
        }

        fn printItems(cs, select=nil) {
            write(__tio.fd, "{ERASE_LINE}\rAvailable completions:\n")

            let (h, w) = __tio.size()

            let n = 0
            for row in fitItems(cs, w) {
                if select in n.range(0, #row - 1) {
                    row[select - n] = chalk"[reverse]{row[select - n]}[/]"
                }
                print(row.join('    '))
                n += #row
            }
        }

        fn draw(start: Int, count: Int) {
            let i = line[;i].map(`#`).sum() ?? 0
            let lines = [(it.str() ?? '').chars() for lines]

            let (lines, line, col) = render(prompt, lines, nr, i)

            let out = Blob()
            let pad = prompt.comb(/\s+$/).sub(/./, '.').pad(prompt.width())

            if start > 0 {
                out.push("\r\x1b[{start}A")
            }

            if count > #lines {
                for ..count {
                    out.push("\r{ERASE_LINE}\n")
                }
                out.push("\x1b[{count}A")
            }

            for text, i in lines {
                if i > 0 {
                    out.push('\n')
                }
                out.push("\r{ERASE_LINE}")
                out.push("{(i == 0) ? prompt : pad}{text}")
            }

            let up = (#lines - line - 1)
            if up > 0 {
                out.push("\x1b[{up}A")
            }

            out.push("\x1b[{1 + col + prompt.width()}G")

            write(__tio.fd, out.str!())
        }

        __tio.start()
        defer __tio.stop()

        let hi = 0
        let hPrefix = nil
        let hSuffix = nil

        let completionCycler = nil

        fn hMatch?(i) {
            if #__history < i { return false }
            let text = __history[-i].0.str() ?? ''
            text.starts?(hPrefix) && text.ends?(hSuffix)
        }

        draw(0, 0)

        while true {
            let nr0 = nr
            let count0 = #lines

            let before = line.slice(0, i).str() ?? ''
            let all = line.str() ?? ''

            if not let $ev = __tio.next-event() {
                continue
            }

            if ev == term.event.EOF {
                return nil
            }

            let key = match ev {
                term.event.Text(_) as t
                    => t,
                term.event.Key({event: 1 or 2, *}) as key
                    => "<{key.nice-name()}>",
                _
                    => do continue
            }

            if key :: String and let $func = keybinds[key] {
                func(*__tio.size())
            }

            let hiStart = hi

            if (key != '<Tab>') && (completionCycler != nil) {
                write(__tio.fd, ERASE_REST)
                completionCycler = nil
            }

            match key {
                '<Enter>', '\n' => {
                    let text = getText()

                    if text != '' && (__history == [] || (line, i) != __history[-1]) {
                        __add-history(lines, nr, i)
                    }

                    if erase {
                        write(__tio.fd, "{ERASE_LINE}\r")
                    } else {
                        write(__tio.fd, '\n')
                    }

                    return text
                },

                '<C-Enter>',
                '<S-Enter>' => {
                    let (before, after) = line.split(i)
                    lines[nr] = before
                    lines.insert(++nr, after)
                    line = lines[nr]
                    i = 0
                },

                '<C-d>' => {
                    return nil
                },

                '<C-a>' => {
                    i = 0
                },

                '<C-e>' => {
                    i = #line
                },

                '<C-k>' => {
                    line.take!(i)
                },

                '<C-l>' => {
                    write(__tio.fd, "\x1b[2J\x1b[H")
                },

                '<C-p>' => {
                    nr = max(nr - 1, 0)
                    line = lines[nr]
                    i = min(i, #line)
                },

                '<C-n>' => {
                    nr = min(nr + 1, #lines - 1)
                    line = lines[nr]
                    i = min(i, #line)
                },

                '<C-w>' => {
                    while i > 0 && line[i - 1].match?(/^\S*$/) {
                        line.pop(--i)
                    }
                    while i > 0 && line[i - 1].match?(/^\s*$/) {
                        line.pop(--i)
                    }
                },

                '<Left>' => {
                    if i > 0 {
                        i -= 1
                    }
                },

                '<Right>' => {
                    if i < #line {
                        i += 1
                    }
                },

                '<Up>' => {
                    hPrefix ?= getBefore()
                    hSuffix ?= getAfter()

                    while hi < #__history {
                        hi += 1
                        if hMatch?(hi) {
                            break
                        }
                    }

                    if hi < #__history && !hMatch?(hi) {
                        hi = hiStart
                    }
                },

                '<Down>' => {
                    hi -= 1

                    while hi > 0 && !hMatch?(hi) {
                        hi -= 1
                    }

                    if (hi < 0) || (hi > 0 && !hMatch?(hi)) {
                        hi = 0
                    }
                },

                '<DEL>',
                '<Backspace>',
                '<S-Backspace>',
                '<C-Backspace>' => {
                    if i > 0 {
                        line.pop(--i)
                    } else if nr > 0 {
                        i = #lines[nr - 1]
                        lines[nr - 1] += line
                        lines.pop(nr--)
                        line = lines[nr]
                    }
                },

                '<C-c>' => {
                    line = []
                    i = 0
                    lines = [line]
                    nr = 0
                },

                '<Tab>' => {
                    if completionCycler != nil {
                        write(__tio.fd, completionCycler.render())
                        (line, i) = completionCycler.cycle()
                    } else {
                        let (before, after) = line.split(i)
                        let result = (
                               complete
                            ?? __complete
                            ?? completeFile
                        )(
                            before.str() ?? '',
                            after.str() ?? ''
                        )
                        match result {
                            Insert(s) => {
                                line.insert(i++, s)
                            },

                            ReplaceLine(s) => {
                                line = s.chars()
                                i = #line
                            },

                            CycleCompletions(cs) and #cs > 0 => {
                                completionCycler = CompletionCycler(cs, line, i)
                                write(__tio.fd, completionCycler.render())
                                (line, i) = completionCycler.cycle()
                            },

                            ListCompletions(cs) and #cs > 0 => {
                                printItems(cs.map(completion-label))
                            },

                            _ => {}
                        }
                    }
                },

                '<C-r>' => {
                    __tio.stop()

                    let fzf = spawn(
                        ['fzf', '--tac', '--no-sort', '-q', getText()],
                        stdin=SPAWN_PIPE,
                        stdout=SPAWN_PIPE,
                        stderr=SPAWN_INHERIT
                    )

                    write(fzf.stdin, __history.map(\_.0.str()).unlines())
                    os::close(fzf.stdin)

                    let out = read(fzf.stdout, 8192).str().strip()
                    os::close(fzf.stdout)
                    wait(fzf.pid)

                    __tio.start()

                    if out {
                        line = out.chars()
                        i = #line
                    }
                },

                '<C-x>' => {
                    let (fd, tmp) = mktemp()
                    os::close(fd)

                    __tio.stop()

                    let editor = spawn([getenv('EDITOR') ?? 'vi', tmp])
                    wait(editor.pid)

                    __tio.start()

                    let out = slurp(tmp).comb(/\r/).sub(/\n+/, ' ').trim()
                    if #out > 0 {
                        line = out.chars()
                        i = #line
                    }
                },

                term.event.Text(s) => {
                    line.insert(i++, s)
                },

                _ => {}
            }

            if hi != hiStart {
                if hi == 0 {
                    line = []
                    i    = 0
                    hi   = 0
                } else {
                    let entry = __history[-hi]
                    lines = entry.lines.map(\_.clone())
                    nr    = entry.i
                    i     = entry.j
                    line  = lines[nr]
                }
            } else if key != '<Up>' {
                hi = 0
                hPrefix = nil
                hSuffix = nil
            }

            lines[nr] = line

            draw(nr0, count0)
        }
    }

    progress(work, prefix, width, effects=id, cleanup=false) {
        for p in work {
            let w = width ?? (__tio.size().1 - 8).clamp(0, 70)
            write(__tio.fd, "\r{prefix ?? ''}{effects(progressString(p, w))} {p * 100:.1f}%%")
        }

        if cleanup {
            write(__tio.fd, "{ERASE_LINE}\r")
        }
    }

    close() {
        if !__borrowed-tio? {
            __tio.close()
        }
    }
}

fn progressString(progress: Float, width: Int) {
    let progress = progress.clamp(0.0, 1.0)
    let wholeWidth = floor(progress * width)
    let remainderWidth = (progress * width) - wholeWidth
    let partWidth = floor(remainderWidth * 8)
    let partChar = [' ', '▏', '▎', '▍', '▌', '▋', '▊', '▉'][partWidth]

    if width - wholeWidth - 1 < 0 {
        partChar = ''
    }

    return "[{'█'.repeat(wholeWidth)}{partChar}{' '.repeat(width - wholeWidth - 1)}]"
}

pub fn progress(work, prefix, width, effects=id, cleanup=false) {
    reader = reader ?? InteractiveLineReader()
    reader.progress(work, prefix, width, effects=effects, cleanup=cleanup)
}

pub fn readln(
    prompt: ?String = nil,
    complete: _ = nil,
    erase: Bool = false,
    keybinds: Dict[String, _] = %{},
    render: RenderFunction | nil = nil
) -> String | nil {
    reader = reader ?? InteractiveLineReader()
    reader.readln(
        prompt=prompt,
        complete=complete,
        erase=erase,
        keybinds=keybinds,
        render=render
    )
}
