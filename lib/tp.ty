tag CanceledError;

class ThreadPool[F: Function] {
  __f:      F
  __setup:  _
  queue:    Array[_]
  mtx:      Mutex
  cv:       CondVar
  stop:     Bool
  threads:  Array[Thread[_]]

  init(n: Int, f: F, setup: _ = nil) {
    __f     = f
    __setup = setup
    queue   = []
    mtx     = Mutex()
    cv      = CondVar()
    stop    = false
    threads = [Thread(cast(runThread), mtx, cv, __f, __setup) for _ in ..n]
  }

  submit[...Args, T](*args: ...Args, %kwargs: _) -> Future[T] where (Args -> T): F {
    mtx.lock()

    let future = Future()

    queue.push((args, kwargs, future))

    mtx.unlock()
    cv.signal()

    return future
  }

  runThread(mtx: Mutex, cv: CondVar, f: _, setup: _ = nil) {
    let state = if setup != nil {
        (setup)()
    }

    while true {
      mtx.lock()

      while !stop && #queue == 0 {
        cv.wait(mtx)
      }

      if stop && #queue == 0 {
        mtx.unlock()
        break
      }

      let (args, kwargs, future) = queue.pop(0)

      mtx.unlock()

      if !future.start() {
        continue
      }

      let x = try {
        f(*args, state if state != nil, **kwargs)
      } catch err {
        future.abort(err)
      }

      future.complete(x)
    }
  }

  close() {
    mtx.lock()
    stop = true
    mtx.unlock()
    cv.broadcast()
    threads.map(&join)
  }

  __drop__() {
    close()
  }
}

ns state {
  const CREATED   = (1 << 0)
  const RUNNING   = (1 << 1)
  const CANCELED  = (1 << 2)
  const ABORTED   = (1 << 3)
  const COMPLETED = (1 << 4)
}

class Future[T] {
  _state: Int
  _mtx:   Mutex
  _cv:    CondVar
  _val:   T
  _err:   Any

  init() {
    _state = state.CREATED
    _cv    = CondVar()
    _mtx   = Mutex()
  }

  wait() {
    let ^_ = _mtx.lock()

    while _state & (state.CREATED | state.RUNNING) {
      _cv.wait(_mtx)
    }

    match _state {
        state.CANCELED  => throw CanceledError,
        state.ABORTED   => throw _err,
        state.COMPLETED => return _val
    }
  }

  start() -> Bool {
    with _mtx {
      if _state == state.CREATED {
        _state = state.RUNNING
        true
      } else {
        false
      }
    }
  }

  cancel() -> Bool {
    with _mtx {
      if _state == state.CREATED {
        _state = state.CANCELED
        _cv.signal()
        true
      } else {
        false
      }
    }
  }

  abort(err: Any) {
    with _mtx {
      _state = state.ABORTED
      _err   = err
      _cv.signal()
    }
  }

  running? {
    with _mtx {
      _state == state.RUNNING
    }
  }

  ready? {
    with _mtx {
      _state == state.COMPLETED
    }
  }

  canceled? {
    with _mtx {
      _state == state.CANCELED
    }
  }

  complete(x: T) {
    with _mtx {
      _state = state.COMPLETED
      _val   = x
      _cv.signal()
    }
  }

  abort(err: Any) {
    with _mtx {
      _state = state.ABORTED
      _err   = err
      _cv.signal()
    }
  }

  static all(fs) {
    let xs = []

    try {
        for f in fs {
            xs.push(f.wait())
        }
    } catch CanceledError {
        return None
    }

    return Some(xs)
  }
}
