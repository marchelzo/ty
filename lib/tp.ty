class ThreadPool[F: Function] {
  __f:       F
  __setup:   _
  __queue:   SharedQueue[_]
  __threads: Array[Thread[_]]

  init(n: Int, f: F, setup: _ = nil) {
    __f       = f
    __setup   = setup
    __queue   = SharedQueue()
    __threads = [Thread(cast(runThread), __f, __setup) for _ in ..n]
  }

  submit[...Args, T](*args: ...Args, %kwargs: _) -> Future[T] where (Args -> T): F {
    let future = Future()
    __queue.put((args, kwargs, future))
    future
  }

  runThread(f: _, setup: _ = nil) {
    let state = if setup != nil {
        (setup)()
    }

    catch _: CanceledError {
        return
    }

    for (;;) {
      let (args, kwargs, future) = __queue.take()

      continue if !future.start()

      try {
        future.complete(f(*args, state if state != nil, **kwargs))
      } catch ex {
        future.abort(ex)
      }
    }
  }

  close() {
    __queue.close()
    __threads.map(&join)
  }

  __drop__() {
    close()
  }
}

ns state {
  const CREATED   = (1 << 0)
  const RUNNING   = (1 << 1)
  const CANCELED  = (1 << 2)
  const ABORTED   = (1 << 3)
  const COMPLETED = (1 << 4)
}

class Future[T] {
  _state: Int
  _mtx:   Mutex
  _cv:    CondVar
  _val:   T
  _err:   Any

  init() {
    _state = state.CREATED
    _cv    = CondVar()
    _mtx   = Mutex()
  }

  wait() -> T {
    let ^_ = _mtx.lock()

    while _state & (state.CREATED | state.RUNNING) {
      _cv.wait(_mtx)
    }

    match _state {
        state.CANCELED  => throw CanceledError(),
        state.ABORTED   => throw _err,
        state.COMPLETED => return _val
    }
  }

  start() -> Bool {
    with _mtx {
      if _state == state.CREATED {
        _state = state.RUNNING
        true
      } else {
        false
      }
    }
  }

  cancel() -> Bool {
    with _mtx {
      if _state == state.CREATED {
        _state = state.CANCELED
        _cv.signal()
        true
      } else {
        false
      }
    }
  }

  abort(err: Any) {
    with _mtx {
      _state = state.ABORTED
      _err   = err
      _cv.signal()
    }
  }

  running? {
    with _mtx {
      _state == state.RUNNING
    }
  }

  ready? {
    with _mtx {
      _state == state.COMPLETED
    }
  }

  canceled? {
    with _mtx {
      _state == state.CANCELED
    }
  }

  complete(x: T) {
    with _mtx {
      _state = state.COMPLETED
      _val   = x
      _cv.signal()
    }
  }

  abort(err: Any) {
    with _mtx {
      _state = state.ABORTED
      _err   = err
      _cv.signal()
    }
  }

  static all(fs) {
    let xs = []

    try {
        for f in fs {
            xs.push(f.wait())
        }
    } catch _: CanceledError {
        return None
    }

    return Some(xs)
  }
}
