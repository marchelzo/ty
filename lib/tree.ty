class Node[K, V] {
    k: K
    v: V
    l: Node[K, V]
    r: Node[K, V]
    p: Node[K, V]
    c: Int
    seen: Bool

    init(k: K, v: V) {
        @k = k
        @v = v
        l = cast(nil)
        r = cast(nil)
        p = cast(nil)
        c = 0
        seen = false
    }
}

pub class Tree[K, V] : Iterable[(K, V)] {
    __null: Node[K, V]
    __root: Node[K, V]

    init() {
        __null = cast(Node())
        __root = __null
        __root.l = __root.r = __root.p = __null
    }

    leftRotate(x: Node[K, V]) {
        let y = x.r
        x.r = y.l
        if y.l != __null {
            y.l.p = x
        }
        y.p = x.p
        if x.p == __null {
            __root = y
        } else if x == x.p.l {
            x.p.l = y
        } else {
            x.p.r = y
        }
        y.l = x
        x.p = y
    }

    empty?() {
        return __root == __null
    }

    size() {
        return treeCount(__root)
    }

    treeCount(x: Node[K, V]) {
        if x == __null {
            return 0
        }
        return 1 + treeCount(x.l) + treeCount(x.r)
    }

    rightRotate(x: Node[K, V]) {
        let y = x.l
        x.l = y.r
        if y.r != __null {
            y.r.p = x
        }
        y.p = x.p
        if x.p == __null {
            __root = y
        } else if x == x.p.r {
            x.p.r = y
        } else {
            x.p.l = y
        }
        y.r = x
        x.p = y
    }

    put(k: K, v: V) {
        let y = __null
        let x = __root
        let z = Node(k, v)
        z.l = z.r = __null
        while x != __null {
            y = x
            match k <=> x.k {
                -1 => { x = x.l },
                 0 => { x.v = v; return v },
                 1 => { x = x.r }
            }
        }
        z.p = y
        if y == __null {
            __root = z
        } else if k < y.k {
            y.l = z
        } else {
            y.r = z
        }
        z.c = 1
        ifixup(z)
        return v
    }

    ifixup(z) {
        while z.p.c {
            if z.p == z.p.p.l {
                let y = z.p.p.r
                if y.c {
                    z.p.c = 0
                    y.c = 0
                    z.p.p.c = 1
                    z = z.p.p
                } else {
                    if z == z.p.r {
                        z = z.p
                        leftRotate(z)
                    }
                    z.p.c = 0
                    z.p.p.c = 1
                    rightRotate(z.p.p)
                }
            } else {
                let y = z.p.p.l
                if y.c {
                    z.p.c = 0
                    y.c = 0
                    z.p.p.c = 1
                    z = z.p.p
                } else {
                    if z == z.p.l {
                        z = z.p
                        rightRotate(z)
                    }
                    z.p.c = 0
                    z.p.p.c = 1
                    leftRotate(z.p.p)
                }
            }
        }
        __root.c = 0
    }

    transplant(u, v) {
        if u.p == __null {
            __root = v
        } else if u == u.p.l {
            u.p.l = v
        } else {
            u.p.r = v
        }
        v.p = u.p
    }

    get(k) {
        let x = findNode(k)
        if x != __null {
            return x.v
        }
    }

    delete(k) {
        let x = findNode(k)
        if x != __null {
            deleteNode(x)
        }
    }

    findNode(k) {
        let x = __root
        while x != __null {
            match k <=> x.k {
                -1 => { x = x.l },
                 0 => { break },
                 1 => { x = x.r }
            }
        }
        return x
    }

    deleteNode(z: Node[K, V]) {
        let y = z
        let yoc = y.c
        let x = __null
        if z.l == __null {
            x = z.r
            transplant(z, z.r)
        } else if z.r == __null {
            x = z.l
            transplant(z, z.l)
        } else {
            y = treeMin(z.r)
            yoc = y.c
            x = y.r
            if y.p == z {
                x.p = y
            } else {
                transplant(y, y.r)
                y.r = z.r
                y.r.p = y
            }
            transplant(z, y)
            y.l = z.l
            y.l.p = y
            y.c = z.c
        }
        if yoc == 0 {
            dfixup(x)
        }
    }

    dfixup(x: Node[K, V]) {
        while x != __root && x.c == 0 {
            if x == x.p.l {
                let w = x.p.r
                if w.c {
                    w.c = 0
                    x.p.c = 1
                    leftRotate(x.p)
                    w = x.p.r
                }
                if w.l.c == 0 && w.r.c == 0 {
                    w.c = 1
                    x = x.p
                } else {
                    if w.r.c == 0 {
                        w.l.c = 0
                        w.c = 1
                        rightRotate(w)
                        w = x.p.r
                    }
                    w.c = x.p.c
                    x.p.c = 0
                    w.r.c = 0
                    leftRotate(x.p)
                    x = __root
                }
            } else {
                let w = x.p.l
                if w.c {
                    w.c = 0
                    x.p.c = 1
                    rightRotate(x.p)
                    w = x.p.l
                }
                if w.r.c == 0 && w.l.c == 0 {
                    w.c = 1
                    x = x.p
                } else {
                    if w.l.c == 0 {
                        w.r.c = 0
                        w.c = 1
                        leftRotate(w)
                        w = x.p.l
                    }
                    w.c = x.p.c
                    x.p.c = 0
                    w.l.c = 0
                    rightRotate(x.p)
                    x = __root
                }
            }
        }
        x.c = 0
    }

    treeMin(x: Node[K, V]) {
        while x.l != __null {
            x = x.l
        }
        return x
    }

    treeMax(x: Node[K, V]) {
        while x.r != __null {
            x = x.r
        }
        return x
    }

    min() {
        let x = treeMin(__root)
        return x.k, x.v
    }

    max() {
        let x = treeMax(__root)
        return x.k, x.v
    }

    has?(k) {
        findNode(k) != __null
    }

    contains?(k) {
        findNode(k) != __null
    }

    __iter__*() -> Generator[(K, V)] {
        let s = [__root]
        let nodes = []

        while s {
            let x = s.pop()
            if x == __null { continue }
            if x.seen {
                nodes.push(x)
            } else {
                s.push(x.r)
                s.push(x)
                s.push(x.l)
                x.seen = true
            }
        }

        for node in nodes {
            yield (node.k, node.v)
            node.seen = false
        }
    }

    nextNode(x: Node[K, V]) {
        if x.r != __null {
            return treeMin(x.r)
        }

        while x != x.p.l {
            x = x.p
        }

        return x.p
    }

    prevNode(x: Node[K, V]) {
        if x.l != __null {
            return treeMax(x.l)
        }

        while x != x.p.r {
            x = x.p
        }

        return x.p
    }

    prev(k) {
        let x = findNode(k)

        if x == __null {
            return nil
        }

        let x = prevNode(x)

        if x != __null {
            return x.k
        }
    }

    next(k) {
        let x = findNode(k)

        if x == __null {
            return nil
        }

        let x = nextNode(x)

        if x != __null {
            return x.k
        }
    }

    -(b: Tree) -> Tree {
        let t = Tree()
        for (k, v) in self {
            if !b.has?(k) {
                t.put(k, v)
            }
        }
        return t
    }

    &(b: Tree[K, V]) -> Tree[K, V] {
        let t = Tree()
        for (k, v) in self {
            if b.has?(k) {
                t.put(k, v)
            }
        }
        return t
    }

    +(b: Tree[K, V]) -> Tree[K, V] {
        let t = Tree()
        for (k, v) in b { t.put(k, v) }
        for (k, v) in self { t.put(k, v) }
        return t
    }

    union(ts) {
        let t = Tree()
        for t in ts {
            for (k, v) in t { t.put(k, v) }
        }
        return t
    }

    intersect(ts) {
        let t = Tree()
        if let [z, *zs] = ts {
            for (k, v) in z {
                if zs.all?(&has?(k)) {
                    t.put(k, v)
                }
            }
        }
        return t
    }
}

pub function set(xs) {
    let t = Tree()
    for x in xs ?? [] { t.put(x) }
    return t
}
