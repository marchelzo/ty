// jit_arm64.dasc - DynASM ARM64 code generation templates for ty JIT
//
// Processed by: luajit LuaJIT/dynasm/dynasm.lua -o src/jit_arm64.h src/jit_arm64.dasc
//
// The generated jit_arm64.h is included by src/jit.c
//

|.arch arm64
|.actionlist jit_actions
|.section code
|.globals JIT_GLOB_

// --- Integer arithmetic ---

static void jit_emit_add(dasm_State **Dst, int dst, int left, int right) {
        |  add Rx(dst), Rx(left), Rx(right)
}

static void jit_emit_sub(dasm_State **Dst, int dst, int left, int right) {
        |  sub Rx(dst), Rx(left), Rx(right)
}

static void jit_emit_mul(dasm_State **Dst, int dst, int left, int right) {
        |  mul Rx(dst), Rx(left), Rx(right)
}

static void jit_emit_sdiv(dasm_State **Dst, int dst, int left, int right) {
        |  sdiv Rx(dst), Rx(left), Rx(right)
}

static void jit_emit_mod(dasm_State **Dst, int dst, int left, int right) {
        |  sdiv x16, Rx(left), Rx(right)
        |  msub Rx(dst), x16, Rx(right), Rx(left)
}

static void jit_emit_neg(dasm_State **Dst, int dst, int src) {
        |  neg Rx(dst), Rx(src)
}

// --- Bitwise ops ---

static void jit_emit_and(dasm_State **Dst, int dst, int left, int right) {
        |  and Rx(dst), Rx(left), Rx(right)
}

static void jit_emit_or(dasm_State **Dst, int dst, int left, int right) {
        |  orr Rx(dst), Rx(left), Rx(right)
}

static void jit_emit_xor(dasm_State **Dst, int dst, int left, int right) {
        |  eor Rx(dst), Rx(left), Rx(right)
}

static void jit_emit_shl(dasm_State **Dst, int dst, int left, int right) {
        |  lsl Rx(dst), Rx(left), Rx(right)
}

static void jit_emit_shr(dasm_State **Dst, int dst, int left, int right) {
        |  asr Rx(dst), Rx(left), Rx(right)
}

// --- Load immediate ---

static void jit_emit_load_imm(dasm_State **Dst, int dst, int64_t imm) {
        if (imm >= 0 && imm < 65536) {
                |  movz Rx(dst), #imm
        } else if (imm >= -65536 && imm < 0) {
                |  movn Rx(dst), #(~imm)
        } else {
                uint64_t u = (uint64_t)imm;
                |  movz Rx(dst), #(u & 0xFFFF)
                if ((u >> 16) & 0xFFFF) {
                        |  movk Rx(dst), #((u >> 16) & 0xFFFF), lsl #16
                }
                if ((u >> 32) & 0xFFFF) {
                        |  movk Rx(dst), #((u >> 32) & 0xFFFF), lsl #32
                }
                if ((u >> 48) & 0xFFFF) {
                        |  movk Rx(dst), #((u >> 48) & 0xFFFF), lsl #48
                }
        }
}

// --- Move between registers ---

static void jit_emit_mov(dasm_State **Dst, int dst, int src) {
        if (dst != src) {
                |  mov Rx(dst), Rx(src)
        }
}

// --- Comparisons (result is 0 or 1 in dst) ---

static void jit_emit_cmp_eq(dasm_State **Dst, int dst, int left, int right) {
        |  cmp Rx(left), Rx(right)
        |  cset Rx(dst), eq
}

static void jit_emit_cmp_ne(dasm_State **Dst, int dst, int left, int right) {
        |  cmp Rx(left), Rx(right)
        |  cset Rx(dst), ne
}

static void jit_emit_cmp_lt(dasm_State **Dst, int dst, int left, int right) {
        |  cmp Rx(left), Rx(right)
        |  cset Rx(dst), lt
}

static void jit_emit_cmp_le(dasm_State **Dst, int dst, int left, int right) {
        |  cmp Rx(left), Rx(right)
        |  cset Rx(dst), le
}

static void jit_emit_cmp_gt(dasm_State **Dst, int dst, int left, int right) {
        |  cmp Rx(left), Rx(right)
        |  cset Rx(dst), gt
}

static void jit_emit_cmp_ge(dasm_State **Dst, int dst, int left, int right) {
        |  cmp Rx(left), Rx(right)
        |  cset Rx(dst), ge
}

// --- Conditional branches ---

static void jit_emit_cbz(dasm_State **Dst, int reg, int label) {
        |  cbz Rx(reg), =>label
}

static void jit_emit_cbnz(dasm_State **Dst, int reg, int label) {
        |  cbnz Rx(reg), =>label
}

static void jit_emit_jump(dasm_State **Dst, int label) {
        |  b =>label
}

static void jit_emit_label(dasm_State **Dst, int label) {
        |=>label:
}

// ============================================================================
// GENERIC MODE: Value-typed functions with C helper calls
//
// Calling convention:
//   void fn(Ty *ty, Value *result, Value *args, Value *env)
//   x0=ty, x1=result, x2=args, x3=env
//
// Callee-saved register assignments:
//   x19 = Ty *ty
//   x20 = Value *result
//   x21 = Value *args (== &stack.items[fp])
//   x22 = Value *env
//   x23 = operand base pointer (== &stack.items[fp + bound])
//   x24 = fp byte offset into stack (stable across reallocs)
//
// Value slots live in the interpreter's stack at [x23 + i*32].
// ============================================================================
static void jit_emit_gen_prologue(dasm_State **Dst, int bound) {
        |->entry:
        |  stp x29, x30, [sp, #-16]!
        |  mov x29, sp
        |  stp x19, x20, [sp, #-16]!
        |  stp x21, x22, [sp, #-16]!
        |  stp x23, x24, [sp, #-16]!
        // Stash incoming args into callee-saved registers
        |  mov x19, x0
        |  mov x20, x1
        |  mov x21, x2
        |  mov x22, x3
        // x24 = byte offset of fp into stack.items (survives realloc)
        // x24 = args - stack.items
        |  ldr x9, [x19, #OFF_TY_STACK + OFF_VEC_DATA]
        |  sub x24, x21, x9
        // x23 = args + bound * VALUE_SIZE = &stack.items[fp + bound]
        int ops_off = bound * VALUE_SIZE;
        if (ops_off > 0) {
                |  add x23, x21, #ops_off
        } else {
                |  mov x23, x21
        }
}

static void jit_emit_gen_epilogue(dasm_State **Dst) {
        |  ldp x23, x24, [sp], #16
        |  ldp x21, x22, [sp], #16
        |  ldp x19, x20, [sp], #16
        |  ldp x29, x30, [sp], #16
        |  ret
}

// --- Reload x21/x23 after calls that may realloc the stack ---
// x24 holds the stable fp byte offset; bound is known at compile time.
static void jit_emit_reload_stack(dasm_State **Dst, int bound) {
        |  ldr x9, [x19, #OFF_TY_STACK + OFF_VEC_DATA]
        |  add x21, x9, x24
        int ops_off = bound * VALUE_SIZE;
        if (ops_off > 0) {
                |  add x23, x21, #ops_off
        } else {
                |  mov x23, x21
        }
}

// Sync interpreter stack count to JIT's current sp.
// Sets ty->stack.count = (fp + bound + sp)
// x24 holds fp * VALUE_SIZE, so fp = x24 / VALUE_SIZE
// But simpler: x23 points to &stack.items[fp + bound],
// and sp slots past that is where we are.
static void jit_emit_sync_stack_count(dasm_State **Dst, int bound, int sp) {
        // stack.count = fp + bound + sp
        // fp * VALUE_SIZE is in x24
        // We need the integer index, not byte offset.
        // fp = x24 / VALUE_SIZE = x24 >> 5  (assuming VALUE_SIZE == 32)
        |  lsr x16, x24, #5
        int total = bound + sp;
        if (total > 0) {
                |  add x16, x16, #total
        }
        |  str x16, [x19, #OFF_TY_STACK + OFF_VEC_LEN]
}

// --- Memory operations ---

// Load 64-bit from [base + offset]
static void jit_emit_ldr64(dasm_State **Dst, int dst, int base, int offset) {
        |  ldr Rx(dst), [Rx(base), #offset]
}

// Store 64-bit to [base + offset]
static void jit_emit_str64(dasm_State **Dst, int src, int base, int offset) {
        |  str Rx(src), [Rx(base), #offset]
}

// Load byte from [base + offset]
static void jit_emit_ldrb(dasm_State **Dst, int dst, int base, int offset) {
        |  ldrb Rw(dst), [Rx(base), #offset]
}

// Store byte to [base + offset]
static void jit_emit_strb(dasm_State **Dst, int src, int base, int offset) {
        |  strb Rw(src), [Rx(base), #offset]
}

// Store halfword (16-bit) to [base + offset]
static void jit_emit_strh(dasm_State **Dst, int src, int base, int offset) {
        |  strh Rw(src), [Rx(base), #offset]
}

// Store 32-bit word to [base + offset]
static void jit_emit_str32(dasm_State **Dst, int src, int base, int offset) {
        |  str Rw(src), [Rx(base), #offset]
}

// Load pair of 64-bit values from [base + offset]
static void jit_emit_ldp64(dasm_State **Dst, int r1, int r2, int base, int offset) {
        |  ldp Rx(r1), Rx(r2), [Rx(base), #offset]
}

// Store pair of 64-bit values to [base + offset]
static void jit_emit_stp64(dasm_State **Dst, int r1, int r2, int base, int offset) {
        |  stp Rx(r1), Rx(r2), [Rx(base), #offset]
}

// --- Add immediate ---
static void jit_emit_add_imm(dasm_State **Dst, int dst, int src, int imm) {
        if (imm == 0) {
                if (dst != src) {
                        |  mov Rx(dst), Rx(src)
                }
        } else {
                |  add Rx(dst), Rx(src), #imm
        }
}

// --- Indirect call ---
static void jit_emit_call_reg(dasm_State **Dst, int reg) {
        |  blr Rx(reg)
}

// --- Compare register with immediate ---
static void jit_emit_cmp_ri(dasm_State **Dst, int reg, int imm) {
        |  cmp Rx(reg), #imm
}

// Compare 32-bit register with immediate (for int return values)
static void jit_emit_cmp_ri32(dasm_State **Dst, int reg, int imm) {
        |  cmp Rw(reg), #imm
}

// --- Conditional branches (use after cmp_ri) ---

static void jit_emit_branch_eq(dasm_State **Dst, int label) {
        |  cset x16, eq
        |  cbnz x16, =>label
}

static void jit_emit_branch_ne(dasm_State **Dst, int label) {
        |  cset x16, ne
        |  cbnz x16, =>label
}

static void jit_emit_branch_lt(dasm_State **Dst, int label) {
        |  cset x16, lt
        |  cbnz x16, =>label
}

static void jit_emit_branch_gt(dasm_State **Dst, int label) {
        |  cset x16, gt
        |  cbnz x16, =>label
}

static void jit_emit_branch_le(dasm_State **Dst, int label) {
        |  cset x16, le
        |  cbnz x16, =>label
}

static void jit_emit_branch_ge(dasm_State **Dst, int label) {
        |  cset x16, ge
        |  cbnz x16, =>label
}

// Load 32-bit word from [base + offset]
static void jit_emit_ldr32(dasm_State **Dst, int dst, int base, int offset) {
        |  ldr Rw(dst), [Rx(base), #offset]
}
