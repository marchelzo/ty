import os (..)

fn assert(condition: bool, message: String) {
    if !condition {
        throw RuntimeError("Assertion failed: {message}")
    }
}

fn test_signals_blocks_and_queries() {
    let blocked = Signals(SIGUSR1, SIGUSR2)
    let old = blocked.block()

    raise(SIGUSR1)

    assert(SIGUSR1 in Signals.pending, "SIGUSR1 should be pending after block")

    Signals.flush()

    old.set()
}

fn test_signals_wait_retrieves_blocked() {
    let blocked = Signals(SIGUSR1)
    let old = blocked.block()

    let pid = os.getpid()
    kill(pid, SIGUSR1)

    let sig = blocked.wait()
    assert(sig == SIGUSR1, "wait should return SIGUSR1")

    old.set()
}

fn test_signal_handler_fires() {
    let fired = false
    signal(SIGUSR1, fn () {
        fired = true
    })

    let pid = os.getpid()
    kill(pid, SIGUSR1)

    sleep(0.01)
    assert(fired, "signal handler should have executed")
}

fn test_signals_suspend_waits_unblocked() {
    Signals.block(SIGUSR2)

    match fork() {
        0 => {
            let received = false
            signal(SIGUSR2, fn () {
                received = true
            })
            Signals().suspend()
            assert(received, "suspend should wake on SIGUSR2")
            exit(0)
        },

        pid => {
            sleep(0.01)
            kill(pid, SIGUSR2)
            let (_, status) = wait() !
            assert(status == 0, "child should exit cleanly")
        }
    }
}

fn test_signals_restore_mask() {
    let original = Signals.mask
    Signals.block(SIGUSR1)
    original.set()

    let current = Signals.mask
    assert(!current.contains?(SIGUSR1), "mask should restore to original state")
}

fn test_kill_delivers_to_target() {
    match fork() {
        0 => {
            let caught = false
            signal(SIGUSR1, fn () {
                caught = true
            })
            sleep(0.15)
            assert(caught, "child should receive SIGUSR1 from parent")
            exit(0)
        },
        pid => {
            sleep(0.05)
            kill(pid, SIGUSR1)
            wait(pid)
        }
    }
}

fn test_signals_pending_reflects_blocked() {
    let old = Signals(SIGUSR1, SIGUSR2).block()

    Thread.kill(SIGUSR1)
    Thread.kill(SIGUSR2)

    let pending = Signals.pending
    assert(pending.contains?(SIGUSR1), "SIGUSR1 should be pending")
    assert(pending.contains?(SIGUSR2), "SIGUSR2 should be pending")

    pending.flush()

    old.set()
}

fn test_signals_add_remove() {
    let set = Signals(SIGUSR1)
    set.add(SIGUSR2)
    assert(set.contains?(SIGUSR1), "SIGUSR1 should be in set")
    assert(set.contains?(SIGUSR2), "SIGUSR2 should be in set")

    set.del(SIGUSR1)
    assert(!set.contains?(SIGUSR1), "SIGUSR1 should be removed")
    assert(set.contains?(SIGUSR2), "SIGUSR2 should remain")
}

fn test_signals_clear_fill() {
    let set = Signals.full
    assert(set.contains?(SIGUSR1), "full set should contain SIGUSR1")

    set.clear()
    assert(!set.contains?(SIGUSR1), "cleared set should not contain SIGUSR1")

    set.fill()
    assert(set.contains?(SIGUSR1), "filled set should contain SIGUSR1")
}

fn test_signals_unblock() {
    let old = Signals.block(SIGUSR1)
    assert(Signals.mask.contains?(SIGUSR1), "SIGUSR1 should be blocked")

    Signals(SIGUSR1).unblock()
    assert(!Signals.mask.contains?(SIGUSR1), "SIGUSR1 should be unblocked")

    old.set()
}

fn run_all_tests() {
    let tests = [
        test_signals_blocks_and_queries,
        test_signals_wait_retrieves_blocked,
        test_signal_handler_fires,
        test_signals_suspend_waits_unblocked,
        test_signals_restore_mask,
        test_kill_delivers_to_target,
        test_signals_pending_reflects_blocked,
        test_signals_add_remove,
        test_signals_clear_fill,
        test_signals_unblock
    ]

    for test in tests {
        test()
        sleep(0.001)
    }

    print('PASS')
}

run_all_tests()
